<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>【lc】买卖股票的最佳时机II</title>
      <link href="/2024/04/03/%E3%80%90lc%E3%80%91%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BAII/"/>
      <url>/2024/04/03/%E3%80%90lc%E3%80%91%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BAII/</url>
      
        <content type="html"><![CDATA[<p>题目</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">给你一个整数数组 prices ，其中 prices[i] 表示某支股票第 i 天的价格。</span><br><span class="line">在每一天，你可以决定是否购买和/或出售股票。你在任何时候 最多 只能持有 一股 股票。你也可以先购买，然后在 同一天 出售。</span><br><span class="line">返回 你能获得的 最大 利润 。</span><br><span class="line"></span><br><span class="line">示例 1：</span><br><span class="line">输入：prices = [7,1,5,3,6,4]</span><br><span class="line">输出：7</span><br><span class="line">解释：在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5 - 1 = 4 。</span><br><span class="line">     随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6 - 3 = 3 。</span><br><span class="line">     总利润为 4 + 3 = 7 。</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入：prices = [1,2,3,4,5]</span><br><span class="line">输出：4</span><br><span class="line">解释：在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5 - 1 = 4 。</span><br><span class="line">     总利润为 4 。</span><br><span class="line"></span><br><span class="line">示例 3：</span><br><span class="line">输入：prices = [7,6,4,3,1]</span><br><span class="line">输出：0</span><br><span class="line">解释：在这种情况下, 交易无法获得正利润，所以不参与交易可以获得最大利润，最大利润为 0 。</span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line">1 &lt;= prices.length &lt;= 3 * 104</span><br><span class="line">0 &lt;= prices[i] &lt;= 104</span><br></pre></td></tr></table></figure><p>思路1</p><p>因为我们拥有千里眼，可以预知明天的股票价格，因此，我们可以使用贪心策略</p><p>只要明天价格比今天高，那么就今天买明天卖</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maxProfit</span>(<span class="params">self, prices: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(prices) - <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> prices[i + <span class="number">1</span>] &gt; prices[i]:</span><br><span class="line">                res += prices[i + <span class="number">1</span>] - prices[i]</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><p>思路2</p><p><a href="https://www.bilibili.com/video/BV1ho4y1W7QK/">参考</a></p><p>状态机，定义</p><p><code>dfs(i, 0)</code>为第<code>i</code>天未持有股票的最大利润</p><p><code>dfs(i, 1)</code>为第<code>i</code>天持有股票的最大利润</p><p>有状态转移方程</p><p><code>dfs(i, 0) = max(dfs(i - 1, 0), dfs(i - 1, 1) + prices[i])</code></p><p><code>dfs(i, 1) = max(dfs(i - 1, 1), dfs(i - 1, 0) - prices[i])</code></p><p>我们可以倒着推，最后的结果一定是<code>dfs(n - 1, 0)</code>，因为<code>dfs(n - 1, 0)</code> 一定大于 <code>dfs(n - 1, 1)</code></p><p>代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maxProfit</span>(<span class="params">self, prices: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        n = <span class="built_in">len</span>(prices)</span><br><span class="line"><span class="meta">        @cache</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">i, hold</span>):</span><br><span class="line">            <span class="keyword">if</span> i &lt; <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span> -inf <span class="keyword">if</span> hold <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line">            <span class="keyword">if</span> hold:</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">max</span>(dfs(i-<span class="number">1</span>,<span class="number">1</span>), dfs(i-<span class="number">1</span>,<span class="number">0</span>) - prices[i])</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">max</span>(dfs(i-<span class="number">1</span>, <span class="number">0</span>), dfs(i-<span class="number">1</span>,<span class="number">1</span>) + prices[i])</span><br><span class="line">        <span class="keyword">return</span> dfs(n-<span class="number">1</span>,<span class="number">0</span>)</span><br></pre></td></tr></table></figure><p>将递归翻译成递推</p><p><code>f[i][0] = max(f[i-1][0], f[i-1][1] + prices[i])</code></p><p><code>f[i][1] = max(f[i-1][1], f[i-1][0] - prices[i])</code></p><p>但是这样没有状态表示<code>f[-1][0]</code>和<code>f[-1][1]</code>，所以要在最前面插入一个状态，剩下的<code>i</code>要向后移</p><p>最终的递推表达式<br><code>f[0][0]=0</code></p><p><code>f[0][1]=-inf</code></p><p><code>f[i+1][0] = max(f[i][0], f[i][1]+prices[i])</code></p><p><code>f[i+1][1] = max(f[i][1], f[i][0]-prices[i])</code></p><p>答案为<code>f[n][0]</code></p><p>代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maxProfit</span>(<span class="params">self, prices: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        n = <span class="built_in">len</span>(prices)</span><br><span class="line">        f = [[<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>)] <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n + <span class="number">1</span>)]</span><br><span class="line">        f[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">        f[<span class="number">0</span>][<span class="number">1</span>] = -inf</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            f[i+<span class="number">1</span>][<span class="number">0</span>] = <span class="built_in">max</span>(f[i][<span class="number">0</span>], f[i][<span class="number">1</span>] + prices[i])</span><br><span class="line">            f[i+<span class="number">1</span>][<span class="number">1</span>] = <span class="built_in">max</span>(f[i][<span class="number">1</span>], f[i][<span class="number">0</span>] - prices[i])</span><br><span class="line">        <span class="keyword">return</span> f[n][<span class="number">0</span>]</span><br></pre></td></tr></table></figure><p>进一步优化，由于<code>f[i+1][0]和f[i+1][1]只用到了f[i][0]和f[i][1]这两个变量</code>所以只需要使用两个变量滚动计算即可</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maxProfit</span>(<span class="params">self, prices: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        n = <span class="built_in">len</span>(prices)</span><br><span class="line">        f = [[<span class="number">0</span>] * <span class="number">2</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n + <span class="number">1</span>)]</span><br><span class="line">        f0 = <span class="number">0</span></span><br><span class="line">        f1 = -inf</span><br><span class="line">        <span class="keyword">for</span> price <span class="keyword">in</span> prices:</span><br><span class="line">            new_f0 = <span class="built_in">max</span>(f0, f1 + price)</span><br><span class="line">            f1 = <span class="built_in">max</span>(f1, f0 - price)</span><br><span class="line">            f0 = new_f0</span><br><span class="line">        <span class="keyword">return</span> f0</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【lc】买卖股票的最佳时机</title>
      <link href="/2024/04/03/%E3%80%90lc%E3%80%91%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA/"/>
      <url>/2024/04/03/%E3%80%90lc%E3%80%91%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA/</url>
      
        <content type="html"><![CDATA[<p>题目</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">给定一个数组 prices ，它的第 i 个元素 prices[i] 表示一支给定股票第 i 天的价格。</span><br><span class="line">你只能选择 某一天 买入这只股票，并选择在 未来的某一个不同的日子 卖出该股票。设计一个算法来计算你所能获取的最大利润。</span><br><span class="line">返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 0 。</span><br><span class="line"></span><br><span class="line">示例 1：</span><br><span class="line">输入：[7,1,5,3,6,4]</span><br><span class="line">输出：5</span><br><span class="line">解释：在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。</span><br><span class="line">     注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票。</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入：prices = [7,6,4,3,1]</span><br><span class="line">输出：0</span><br><span class="line">解释：在这种情况下, 没有交易完成, 所以最大利润为 0。</span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line">1 &lt;= prices.length &lt;= 105</span><br><span class="line">0 &lt;= prices[i] &lt;= 104</span><br></pre></td></tr></table></figure><p>思路</p><p>维护两个变量即可，最小的价钱和最高的利润</p><p>代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maxProfit</span>(<span class="params">self, prices: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        minprice, maxprofit = <span class="built_in">float</span>(<span class="string">&#x27;inf&#x27;</span>), <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> prices:</span><br><span class="line">            <span class="keyword">if</span> x &lt; minprice:</span><br><span class="line">                minprice = x</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                maxprofit = <span class="built_in">max</span>(maxprofit, x - minprice)</span><br><span class="line">        <span class="keyword">return</span> maxprofit</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Redis】持久化机制</title>
      <link href="/2024/04/02/%E3%80%90Redis%E3%80%91%E6%8C%81%E4%B9%85%E5%8C%96%E6%9C%BA%E5%88%B6/"/>
      <url>/2024/04/02/%E3%80%90Redis%E3%80%91%E6%8C%81%E4%B9%85%E5%8C%96%E6%9C%BA%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<p>什么是持久化</p><blockquote><p>维基百科对于持久化的解释：在<a href="https://zh.wikipedia.org/wiki/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6">计算机科学</a>中，<strong>持久性</strong>是<a href="https://zh.wikipedia.org/w/index.php?title=%E7%B3%BB%E7%BB%9F%E7%8A%B6%E6%80%81&action=edit&redlink=1">系统状态</a>的一个特征。一般计算机是将某个状态作为<a href="https://zh.wikipedia.org/wiki/%E6%95%B0%E6%8D%AE">数据</a>存储在<a href="https://zh.wikipedia.org/wiki/%E9%9B%BB%E8%85%A6%E6%95%B8%E6%93%9A%E5%AD%98%E8%B2%AF%E5%99%A8">电脑数据存贮器</a>以实现<strong>持久化</strong>。程式必须将数据存储在储存设备以及从存储设备中读取数据，并且必须提供本地<a href="https://zh.wikipedia.org/wiki/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80">编程语言</a>数据结构和<a href="https://zh.wikipedia.org/wiki/%E5%AD%98%E5%82%A8%E8%AE%BE%E5%A4%87">存储设备</a><a href="https://zh.wikipedia.org/wiki/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84">数据结构</a>之间的<a href="https://zh.wikipedia.org/wiki/%E6%98%A0%E5%B0%84">映射</a>[<a href="https://zh.wikipedia.org/zh-cn/%E6%8C%81%E4%B9%85%E5%8C%96#cite_note-1">1]</a>。</p></blockquote><p>简单来讲，就是将数据放在一个可以自动永久(近似)保存的地方</p><p>Redis为什么要持久化</p><p>因为Redis是基于内存的数据库，在Redis运行期间，其数据都是存在内存中的，一旦机器宕机或者重启，那么数据就丢失了。</p><blockquote><p>内存：RAM，易失性存储设备，断电之后无法保存信息。</p></blockquote><p>Redis持久化的几种方式</p><ol><li>RDB（Redis DataBase）</li><li>AOF（Append Only File）</li><li>混合持久化方式</li></ol><h2 id="RDB"><a href="#RDB" class="headerlink" title="RDB"></a>RDB</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>保存某一时刻的内存快照，以二进制形式写入磁盘。</p><h3 id="触发方式"><a href="#触发方式" class="headerlink" title="触发方式"></a>触发方式</h3><h4 id="手动触发"><a href="#手动触发" class="headerlink" title="手动触发"></a>手动触发</h4><p><code>save</code>和<code>bgsave</code>：他们俩的主要区别在于是否阻塞主线程。</p><h5 id="save命令"><a href="#save命令" class="headerlink" title="save命令"></a>save命令</h5><p>客户端执行save命令后，会触发Redis持久化，但同时会使Redis处于阻塞状态….直至Redis完成持久化，才会详情其他请求。</p><p>因此，生产环境要慎用。</p><p><img src="https://coldwater.oss-cn-beijing.aliyuncs.com/img/20240402232840.png"></p><h5 id="bgsave命令"><a href="#bgsave命令" class="headerlink" title="bgsave命令"></a>bgsave命令</h5><p>bgsave（background save）也就是后台保存，fork()一个子进程来进行持久化，也就是fork()的时候会稍微阻塞一下主线程，时间很短暂。</p><p><img src="https://coldwater.oss-cn-beijing.aliyuncs.com/img/20240402232830.png"></p><h4 id="自动触发"><a href="#自动触发" class="headerlink" title="自动触发"></a>自动触发</h4><h5 id="save-m-n"><a href="#save-m-n" class="headerlink" title="save m n"></a>save m n</h5><p><code>save m n</code>的意思是在m秒内，如果有n个键发生变化，则触发一次bgsave。</p><p>注意，当设置了多个<code>save m n</code>时，满足多个就执行多个。</p><h5 id="flushall"><a href="#flushall" class="headerlink" title="flushall"></a>flushall</h5><p>会清空数据库，生产环境慎用，当执行<code>flushall</code>之后，会自动执行<code>bgsave</code></p><h5 id="主从同步触发"><a href="#主从同步触发" class="headerlink" title="主从同步触发"></a>主从同步触发</h5><p>主从复制的时候，当从节点执行全量复制的时候，主节点会执行<code>bgsave</code>命令，并将RDB文件发从给从节点。</p><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p>RDB参数配置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"># RDB 保存的条件</span><br><span class="line">save 900 1</span><br><span class="line">save 300 10</span><br><span class="line">save 60 10000</span><br><span class="line"></span><br><span class="line"># bgsave 失败之后，是否停止持久化数据到磁盘，yes 表示停止持久化，no 表示忽略错误继续写文件。</span><br><span class="line">stop-writes-on-bgsave-error yes</span><br><span class="line"></span><br><span class="line"># RDB 文件压缩，默认开启，如果不想消耗CPU来压缩的话，可以设置为false，只不过会比较占用磁盘空间了</span><br><span class="line">rdbcompression yes</span><br><span class="line"></span><br><span class="line"># 写入文件和读取文件时是否开启 RDB 文件检查，检查是否有无损坏，如果在启动是检查发现损坏，则停止启动。</span><br><span class="line">rdbchecksum yes</span><br><span class="line"></span><br><span class="line"># RDB 文件名</span><br><span class="line">dbfilename dump.rdb</span><br><span class="line"></span><br><span class="line"># RDB 文件目录</span><br><span class="line">dir ./</span><br></pre></td></tr></table></figure><h3 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h3><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ol><li>RDB内容为二进制文件，占用内存更小，更适合做备份文件</li><li>因为文件小，可以更快的传输到远程服务器，对灾难恢复很有用</li><li>更大程度提高Redis运行速度，因为每次备份都是fork()一个进程出来，所以不会影响Redis主进程工作</li><li>相比于AOF，可以更快的重启</li></ol><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ol><li>因为RDB只能保存某个时间间隔的数据，所以中途Redis停止了，则会丢失一段数据</li><li>需要fork()才能持久化，但如果数据量很大，fork()操作会很耗时（涉及到了大页表。。。）</li></ol><h2 id="AOF"><a href="#AOF" class="headerlink" title="AOF"></a>AOF</h2><h3 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h3><p>Append Only File可以把Redis每个键值对都记录到文件（appendonly.aof）中。</p><h3 id="AOF的查询和设置"><a href="#AOF的查询和设置" class="headerlink" title="AOF的查询和设置"></a>AOF的查询和设置</h3><h4 id="查询状态"><a href="#查询状态" class="headerlink" title="查询状态"></a>查询状态</h4><p><code>config get appendonly</code>：yes表示启动了，no表示没启动</p><h4 id="开启AOF持久化"><a href="#开启AOF持久化" class="headerlink" title="开启AOF持久化"></a>开启AOF持久化</h4><h5 id="命令行方式启动"><a href="#命令行方式启动" class="headerlink" title="命令行方式启动"></a>命令行方式启动</h5><p><code>config set appendonly yes</code></p><p>优点，无需重启redis服务。</p><p>缺点，若redis重启，则配置会失效</p><h5 id="配置文件启动AOF"><a href="#配置文件启动AOF" class="headerlink" title="配置文件启动AOF"></a>配置文件启动AOF</h5><p>先通过<code>config get dir</code>获取<code>redis.conf</code>路径</p><p>在<code>redis.conf</code>中，设置<code>appendonly yes</code>即可。</p><p>优点，之后重启会自动设置开始AOF</p><p>缺点，设置完需要重启。</p><h4 id="触发持久化"><a href="#触发持久化" class="headerlink" title="触发持久化"></a>触发持久化</h4><h5 id="自动触发-1"><a href="#自动触发-1" class="headerlink" title="自动触发"></a>自动触发</h5><p>AOF持久化策略：</p><ul><li><code>always</code>：每条写指令都会写入磁盘</li><li><code>everysec</code>：每秒</li><li><code>no</code>：由OS来确认何时写入，Linux默认30s写入一次</li></ul><p>可以在<code>redis.conf</code>中设置</p><blockquote><p>#开启每秒写入一次的持久化策略</p><p>appendfsync everysec1</p></blockquote><h5 id="手动触发-1"><a href="#手动触发-1" class="headerlink" title="手动触发"></a>手动触发</h5><p>客户端执行<code>bgrewriteaof</code>可以手动触发AOF持久化。</p><h3 id="AOF文件重写"><a href="#AOF文件重写" class="headerlink" title="AOF文件重写"></a>AOF文件重写</h3><h4 id="AOF重写实现"><a href="#AOF重写实现" class="headerlink" title="AOF重写实现"></a>AOF重写实现</h4><p>触发AOF文件重写，要满足两个条件，这两个条件都是在redis的配置文件中</p><ul><li><code>auto-aof-rewrite-min-size</code>：允许AOF重写的最小文件容量，默认为64mb</li><li><code>auto-aof-rewrite-percentage</code>：AOF文件重写比例大小。默认是100，也就是100%，表示当前AOF文件比上一次的AOF文件大一倍的时候，才会启动AOF重写。</li></ul><h4 id="AOF重写流程"><a href="#AOF重写流程" class="headerlink" title="AOF重写流程"></a>AOF重写流程</h4><p>生成一个全新文件，把之前的数据的<strong>最少操作命令</strong>保存到新文件，当都保存到新文件后，Redis会交换两个文件，并把最新的持久化操作命令追加到新文件。</p><h3 id="数据恢复"><a href="#数据恢复" class="headerlink" title="数据恢复"></a>数据恢复</h3><h4 id="正常数据恢复"><a href="#正常数据恢复" class="headerlink" title="正常数据恢复"></a>正常数据恢复</h4><h5 id="持久化文件加载规则"><a href="#持久化文件加载规则" class="headerlink" title="持久化文件加载规则"></a>持久化文件加载规则</h5><ul><li>若只开启了AOF，则只会加载AOF文件（appendonly.aof）</li><li>若之开启了RDB，则只会加载RDB文件（dump.rdb）</li><li>若同时开启了AOF和RDB，则只会加载AOF文件（appendonly.aof）</li></ul><h5 id="简单异常数据恢复"><a href="#简单异常数据恢复" class="headerlink" title="简单异常数据恢复"></a>简单异常数据恢复</h5><p>若损失了最后一条命令，如果开始了<code>aof-load-truncated yes</code>，则会忽略最后一条命令。正常启动Redis。</p><h5 id="复杂异常数据恢复"><a href="#复杂异常数据恢复" class="headerlink" title="复杂异常数据恢复"></a>复杂异常数据恢复</h5><p>若AOF中间的命令被破坏</p><ol><li>首先使用AOF修复工具，检测问题，尝试手动修复。</li><li>若无法手动修复，则尝试自动修复，也可能会导致异常部分至末尾的数据全部被丢弃。</li></ol><h3 id="优缺点-1"><a href="#优缺点-1" class="headerlink" title="优缺点"></a>优缺点</h3><p>优点</p><ul><li>AOF持久化方式保存的数据更加完整</li><li>AOF采用命令追加方式，不会出现文件损坏问题。</li><li>AOF持久化文件非常容易解析</li></ul><p>缺点</p><ul><li>相同数据量，AOF文件要比RDB文件大</li><li>Redis负载较高的情况下，RDB比AOF性能更好</li><li>理论上来说，RDB比AOF更加健壮</li></ul><h2 id="混合持久化"><a href="#混合持久化" class="headerlink" title="混合持久化"></a>混合持久化</h2><p>在开启混合持久化的情况下，AOF 重写时会把 Redis 的持久化数据，<strong>以 RDB 的格式</strong>写入到 <strong>AOF 文件的开头</strong>，之后的数据再以 AOF 的格式化追加的文件的末尾。</p><p>混合持久化的数据存储结构如下图所示：</p><p><img src="https://coldwater.oss-cn-beijing.aliyuncs.com/img/20240403201745.png"></p><h3 id="开启混合持久化"><a href="#开启混合持久化" class="headerlink" title="开启混合持久化"></a>开启混合持久化</h3><h4 id="命令行开启"><a href="#命令行开启" class="headerlink" title="命令行开启"></a>命令行开启</h4><p><code>config set aof-use-rdb-preamble yes</code></p><h4 id="通过修改Redis配置文件开启"><a href="#通过修改Redis配置文件开启" class="headerlink" title="通过修改Redis配置文件开启"></a>通过修改Redis配置文件开启</h4><p>找到<code>redis.conf</code>，把配置文件中的<code>aof-use-rdb-preamble no</code>修改为<code>aof-use-rdb-preamble yes</code></p><h3 id="数据恢复和源码分析"><a href="#数据恢复和源码分析" class="headerlink" title="数据恢复和源码分析"></a>数据恢复和源码分析</h3><p>数据恢复和AOF是一样的，只要把<code>appendonly.aof</code>文件放入<code>Redis</code>根目录，在Redis启动时，只要开启了AOF持久化，Redis就会自动加载并恢复数据。</p><h4 id="混合持久化加载流程"><a href="#混合持久化加载流程" class="headerlink" title="混合持久化加载流程"></a>混合持久化加载流程</h4><ol><li>判断是否开启 AOF 持久化，开启继续执行后续流程，未开启执行加载 RDB 文件的流程；</li><li>判断 <code>appendonly.aof</code> 文件是否存在，文件存在则执行后续流程；</li><li>判断 AOF 文件开头是 RDB 的格式, 先加载 RDB 内容再加载剩余的 AOF 内容；</li><li>判断 AOF 文件开头不是 RDB 的格式，直接以 AOF 格式加载整个文件。</li></ol><p><img src="https://coldwater.oss-cn-beijing.aliyuncs.com/img/20240403202213.png"></p><h4 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> sig[<span class="number">5</span>]; <span class="comment">/* &quot;REDIS&quot; */</span></span><br><span class="line"><span class="keyword">if</span> (fread(sig,<span class="number">1</span>,<span class="number">5</span>,fp) != <span class="number">5</span> || <span class="built_in">memcmp</span>(sig,<span class="string">&quot;REDIS&quot;</span>,<span class="number">5</span>) != <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// AOF 文件开头非 RDB 格式，非混合持久化文件</span></span><br><span class="line">    <span class="keyword">if</span> (fseek(fp,<span class="number">0</span>,SEEK_SET) == <span class="number">-1</span>) <span class="keyword">goto</span> readerr;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">/* RDB preamble. Pass loading the RDB functions. */</span></span><br><span class="line">    rio rdb;</span><br><span class="line"></span><br><span class="line">    serverLog(LL_NOTICE,<span class="string">&quot;Reading RDB preamble from AOF file...&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (fseek(fp,<span class="number">0</span>,SEEK_SET) == <span class="number">-1</span>) <span class="keyword">goto</span> readerr;</span><br><span class="line">    rioInitWithFile(&amp;rdb,fp);</span><br><span class="line">    <span class="comment">// AOF 文件开头是 RDB 格式，先加载 RDB 再加载 AOF</span></span><br><span class="line">    <span class="keyword">if</span> (rdbLoadRio(&amp;rdb,<span class="literal">NULL</span>,<span class="number">1</span>) != C_OK) &#123;</span><br><span class="line">        serverLog(LL_WARNING,<span class="string">&quot;Error reading the RDB preamble of the AOF file, AOF loading aborted&quot;</span>);</span><br><span class="line">        <span class="keyword">goto</span> readerr;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        serverLog(LL_NOTICE,<span class="string">&quot;Reading the remaining AOF tail...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 加载 AOF 格式的数据</span></span><br></pre></td></tr></table></figure><blockquote><p>AOF格式文件开头是*，而RDB格式文件开头是REDIS</p></blockquote><h3 id="优缺点-2"><a href="#优缺点-2" class="headerlink" title="优缺点"></a>优缺点</h3><h4 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h4><p>融合了AOF和RDB的有带你，开头为RDB格式文件，使得Redis快速启动，同时结合了AOF，降低了数据丢失风险。</p><h4 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h4><ul><li>AOF文件添加了RDB格式的内容，使得AOF文件内容可读性变差</li></ul><h3 id="持久化最佳实践"><a href="#持久化最佳实践" class="headerlink" title="持久化最佳实践"></a>持久化最佳实践</h3><h4 id="控制持久化开关"><a href="#控制持久化开关" class="headerlink" title="控制持久化开关"></a>控制持久化开关</h4><p>根据实际的业务情况，如果对于丢失redis数据不敏感，则可以考虑关闭redis持久化。</p><ul><li>关闭RDB持久化：<code>config set save &quot;&quot;</code></li><li>关闭AOF和混合持久化：<code>config set appendonly no</code></li></ul><h4 id="主从部署"><a href="#主从部署" class="headerlink" title="主从部署"></a>主从部署</h4><p>使用主从部署，一台用于响应主业务，一台用于持久化，更高效了</p><h4 id="使用混合持久化"><a href="#使用混合持久化" class="headerlink" title="使用混合持久化"></a>使用混合持久化</h4><p>redis5.0默认开启</p>]]></content>
      
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【lc】完全平方数</title>
      <link href="/2024/04/02/%E3%80%90lc%E3%80%91%E5%AE%8C%E5%85%A8%E5%B9%B3%E6%96%B9%E6%95%B0/"/>
      <url>/2024/04/02/%E3%80%90lc%E3%80%91%E5%AE%8C%E5%85%A8%E5%B9%B3%E6%96%B9%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<p>题目</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">给你一个整数 n ，返回 和为 n 的完全平方数的最少数量 。</span><br><span class="line">完全平方数 是一个整数，其值等于另一个整数的平方；换句话说，其值等于一个整数自乘的积。例如，1、4、9 和 16 都是完全平方数，而 3 和 11 不是。</span><br><span class="line"></span><br><span class="line">示例 1：</span><br><span class="line">输入：n = 12</span><br><span class="line">输出：3 </span><br><span class="line">解释：12 = 4 + 4 + 4</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入：n = 13</span><br><span class="line">输出：2</span><br><span class="line">解释：13 = 4 + 9</span><br><span class="line"> </span><br><span class="line">提示：</span><br><span class="line">1 &lt;= n &lt;= 104</span><br></pre></td></tr></table></figure><p>思路</p><p>动态规划，设置<code>dp[i]</code>表示最少有多少个完全平方数可以组成<code>i</code></p><p>那么当我们遇到一个数<code>x</code>的时候，我们可以先遍历小于<code>x</code>的完全平方数<code>k</code>，然后<code>i</code>的答案就是<code>dp[x-k]+1</code>和<code>dp[i]</code>之间的最小值</p><p>故，状态转移方程为<code>dp[i] = min(dp[i], dp[i - k] + 1)</code></p><p>代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">numSquares</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        square = [i * i <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">101</span>)]</span><br><span class="line">        dp = [<span class="number">0</span>] + [<span class="built_in">float</span>(<span class="string">&#x27;inf&#x27;</span>)] * n</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n + <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> k <span class="keyword">in</span> square:</span><br><span class="line">                <span class="keyword">if</span> k &lt;= i:</span><br><span class="line">                    dp[i] = <span class="built_in">min</span>(dp[i], dp[i - k] + <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> dp[n]</span><br></pre></td></tr></table></figure><p>时间复杂度O(n * sqrt(n))</p><p>空间复杂度为O(sqrt(n))</p><p>我们可以优化一下空间复杂度</p><p>因为上面代码中的最大的<code>k</code>也是小于等于<code>sqrt(i)</code>的，所以我们可以省下<code>square</code>的空间</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">numSquares</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        dp = [<span class="number">0</span>] + [<span class="built_in">float</span>(<span class="string">&#x27;inf&#x27;</span>)] * n</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n + <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">int</span>(i ** <span class="number">0.5</span>) + <span class="number">1</span>):</span><br><span class="line">                dp[i] = <span class="built_in">min</span>(dp[i], dp[i - k * k] + <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> dp[n]</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Redis】数据结构-跳跃表SkipList</title>
      <link href="/2024/03/30/%E3%80%90Redis%E3%80%91%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E8%B7%B3%E8%B7%83%E8%A1%A8SkipList/"/>
      <url>/2024/03/30/%E3%80%90Redis%E3%80%91%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E8%B7%B3%E8%B7%83%E8%A1%A8SkipList/</url>
      
        <content type="html"><![CDATA[<p>结构：</p><p>跳表</p><p>跳表的目的：在链表中实现二分查找</p><p>整体结构图</p><img src="https://coldwater.oss-cn-beijing.aliyuncs.com/img/tiaobiao.png" style="height:340px" /><p><code>header</code>指向跳表表头节点</p><p><code>tail</code>指向跳表表尾节点</p><p><code>level</code>记录层数最大的节点的层数</p><p><code>length</code>记录跳表长度（节点数量，表头节点不算）</p><p><code>backward</code>后退指针，指向位于当前节点前的一个节点。使用时机：在从表尾向表头遍历的时候使用。</p><p><code>score</code>分值。。跳表中，节点按照各自所保存的分值从小到达排序。</p><p><code>obj</code>各个节点中obj保存的是成员对象。</p><p>跳表节点的结构定义：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistLevel</span> &#123;</span></span><br><span class="line">        <span class="comment">// 前进指针</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> *<span class="title">forward</span>;</span></span><br><span class="line">        <span class="comment">// 跨度：两节点直接距离</span></span><br><span class="line">        <span class="type">unsigned</span> <span class="type">int</span> span;</span><br><span class="line">    &#125; level[];</span><br><span class="line">    <span class="comment">// 后退指针</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> *<span class="title">backward</span>;</span></span><br><span class="line">    <span class="comment">// 分数</span></span><br><span class="line">    <span class="type">double</span> score;</span><br><span class="line">    <span class="comment">// 成员对象（实际保存的数据）</span></span><br><span class="line">    robj *obj;</span><br><span class="line">&#125; zskiplistNode;</span><br></pre></td></tr></table></figure><p>跨度span，用来计算排位。</p><p>如果要<strong>倒序遍历</strong>节点的话，会通过<code>tail</code>指针找到最后一个节点，然后再通过<code>backward</code>指针倒序遍历，直到为<code>NULL</code>。</p><p>跳表中，各节点保存的成员对象必须唯一，但是多个节点保存的分数可以相同，相同分数的节点，按照成员对象的字典序大小排序（由小到大）。</p><p>跳表定义</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">zskiplist</span> &#123;</span></span><br><span class="line">    <span class="comment">// 表头&amp;表尾节点</span></span><br><span class="line">    structz skiplistNode *header, *tail;</span><br><span class="line">    <span class="comment">// 表中节点的数量</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> length;</span><br><span class="line">    <span class="comment">// 表中层数最大节点的层数</span></span><br><span class="line">    <span class="type">int</span> level;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实<strong>跳表节点</strong>之间就可以组成一个<strong>跳表</strong>。但是如果我们定义一个<strong>跳表结构</strong>，则会更方便的对整个跳表进行处理。比如快速访问头、尾节点、获取长度。</p><img src="https://coldwater.oss-cn-beijing.aliyuncs.com/img/20240331092711.png" style="height:700px" /><p>创建跳表</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建一个空表头的跳跃表</span></span><br><span class="line">zskiplist *<span class="title function_">zslCreate</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="type">int</span> j;</span><br><span class="line">    zskiplist *zsl;</span><br><span class="line">    <span class="comment">//尝试分配内存空间</span></span><br><span class="line">    zsl = zmalloc(<span class="keyword">sizeof</span>(*zsl));</span><br><span class="line">    <span class="comment">//初始化level和length</span></span><br><span class="line">    zsl-&gt;level = <span class="number">1</span>;</span><br><span class="line">    zsl-&gt;length = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//调用下面的方法zslCreateNode,传入的参数有数组长度ZSKIPLIST_MAXLEVEL 32</span></span><br><span class="line">    <span class="comment">//分数0，对象值NuLL</span></span><br><span class="line">    <span class="comment">//这一步就是创建管理所有节点的数组</span></span><br><span class="line">    <span class="comment">//并且设置表头的头头指针为此对象的地址</span></span><br><span class="line">    zsl-&gt;header = zslCreateNode(ZSKIPLIST_MAXLEVEL,<span class="number">0</span>,<span class="literal">NULL</span>);</span><br><span class="line">    <span class="comment">//为这32个数组赋值前指针forward和跨度span</span></span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; ZSKIPLIST_MAXLEVEL; j++) &#123;</span><br><span class="line">        zsl-&gt;header-&gt;level[j].forward = <span class="literal">NULL</span>;</span><br><span class="line">        zsl-&gt;header-&gt;level[j].span = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//设置尾指针</span></span><br><span class="line">    zsl-&gt;header-&gt;backward = <span class="literal">NULL</span>;</span><br><span class="line">    zsl-&gt;tail = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">//返回对象</span></span><br><span class="line">    <span class="keyword">return</span> zsl;</span><br><span class="line">&#125;</span><br><span class="line">zskiplistNode *<span class="title function_">zslCreateNode</span><span class="params">(<span class="type">int</span> level, <span class="type">double</span> score, sds ele)</span> &#123;</span><br><span class="line">    zskiplistNode *zn =</span><br><span class="line">        zmalloc(<span class="keyword">sizeof</span>(*zn)+level*<span class="keyword">sizeof</span>(<span class="keyword">struct</span> zskiplistLevel));</span><br><span class="line">    zn-&gt;score = score;</span><br><span class="line">    zn-&gt;ele = ele;</span><br><span class="line">    <span class="keyword">return</span> zn;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>插入节点</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//插入节点，输入参数为</span></span><br><span class="line"><span class="comment">//zsl:表头</span></span><br><span class="line"><span class="comment">//score:插入元素的分数score</span></span><br><span class="line"><span class="comment">//ele:插入元素的具体数据ele</span></span><br><span class="line">zskiplistNode *<span class="title function_">zslInsert</span><span class="params">(zskiplist *zsl, <span class="type">double</span> score, sds ele)</span> &#123;</span><br><span class="line">    <span class="comment">//使用update数组记录每层待插入元素的前一个元素</span></span><br><span class="line">    zskiplistNode *update[ZSKIPLIST_MAXLEVEL], *x;</span><br><span class="line">    <span class="comment">//记录前置节点与第一个节点之间的跨度，即元素在列表中的排名-1</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> rank[ZSKIPLIST_MAXLEVEL];</span><br><span class="line">    <span class="type">int</span> i, level;</span><br><span class="line"></span><br><span class="line">    serverAssert(!isnan(score));</span><br><span class="line">    x = zsl-&gt;header;</span><br><span class="line">    <span class="comment">//从最大的level开始遍历，从顶到底，找到每一层待插入的位置</span></span><br><span class="line">    <span class="keyword">for</span> (i = zsl-&gt;level<span class="number">-1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="comment">/* store rank that is crossed to reach the insert position */</span></span><br><span class="line">        rank[i] = i == (zsl-&gt;level<span class="number">-1</span>) ? <span class="number">0</span> : rank[i+<span class="number">1</span>];</span><br><span class="line">    <span class="comment">//直接找到第一个分数比该元素大的位置</span></span><br><span class="line">    <span class="comment">//或者分数与该元素相同但是对象的ASSICC码比该元素大的位置</span></span><br><span class="line">        <span class="keyword">while</span> (x-&gt;level[i].forward &amp;&amp;</span><br><span class="line">                (x-&gt;level[i].forward-&gt;score &lt; score ||</span><br><span class="line">                    (x-&gt;level[i].forward-&gt;score == score &amp;&amp;</span><br><span class="line">                    sdscmp(x-&gt;level[i].forward-&gt;ele,ele) &lt; <span class="number">0</span>)))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//将已走过元素的跨越元素进行计数，得到元素在列表中排名，或者是已搜寻的路径长度</span></span><br><span class="line">            rank[i] += x-&gt;level[i].span;</span><br><span class="line">            x = x-&gt;level[i].forward;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="comment">//记录待插入位置</span></span><br><span class="line">        update[i] = x;</span><br><span class="line">    &#125;</span><br><span class="line">     <span class="comment">//随机产生一个层数，在1到32之间，层数越高，生成的概率越低</span></span><br><span class="line">    level = zslRandomLevel();</span><br><span class="line">    <span class="comment">//如果产生的层数大于现有的最高层数，则超出层数都需要初始化</span></span><br><span class="line">    <span class="keyword">if</span> (level &gt; zsl-&gt;level) &#123;</span><br><span class="line">        <span class="comment">//开始循环</span></span><br><span class="line">        <span class="keyword">for</span> (i = zsl-&gt;level; i &lt; level; i++) &#123;</span><br><span class="line">            rank[i] = <span class="number">0</span>;</span><br><span class="line">            <span class="comment">//该元素作为这些层的第一个节点，前节点就是header</span></span><br><span class="line">            update[i] = zsl-&gt;header;</span><br><span class="line">            <span class="comment">//初始化后这些层每层有两个元素，走一步就是跨越所有元素</span></span><br><span class="line">            update[i]-&gt;level[i].span = zsl-&gt;length;</span><br><span class="line">        &#125;</span><br><span class="line">        zsl-&gt;level = level;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//创建节点</span></span><br><span class="line">    x = zslCreateNode(level,score,ele);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; level; i++) &#123;</span><br><span class="line">        <span class="comment">//将新节点插入到各层链表中</span></span><br><span class="line">        x-&gt;level[i].forward = update[i]-&gt;level[i].forward;</span><br><span class="line">        update[i]-&gt;level[i].forward = x;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// rank[0]是第0层的前置节点P1（也就是底层插入节点前面那个节点）与第一个节点的跨度</span></span><br><span class="line">        <span class="comment">// rank[i]是第i层的前置节点P2（这一层里在插入节点前面那个节点）与第一个节点的跨度</span></span><br><span class="line">        <span class="comment">// 插入节点X与后置节点Y的跨度f(X,Y)可由以下公式计算</span></span><br><span class="line">        <span class="comment">// 关键在于f(P1,0)-f(P2,0)+1等于新节点与P2的跨度，这是因为跨度呈扇形形向下延伸到最底层</span></span><br><span class="line">        <span class="comment">// 记录节点各层跨越元素情况span, 由层与层之间的跨越元素总和rank相减而得</span></span><br><span class="line">        x-&gt;level[i].span = update[i]-&gt;level[i].span - (rank[<span class="number">0</span>] - rank[i]);</span><br><span class="line">               <span class="comment">// 插入位置前一个节点的span在原基础上加1即可(新节点在rank[0]的后一个位置)</span></span><br><span class="line"></span><br><span class="line"> update[i]-&gt;level[i].span = (rank[<span class="number">0</span>] - rank[i]) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* increment span for untouched levels */</span></span><br><span class="line">    <span class="keyword">for</span> (i = level; i &lt; zsl-&gt;level; i++) &#123;</span><br><span class="line">        update[i]-&gt;level[i].span++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 第0层是双向链表, 便于redis常支持逆序类查找</span></span><br><span class="line">    x-&gt;backward = (update[<span class="number">0</span>] == zsl-&gt;header) ? <span class="literal">NULL</span> : update[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">if</span> (x-&gt;level[<span class="number">0</span>].forward)</span><br><span class="line">        x-&gt;level[<span class="number">0</span>].forward-&gt;backward = x;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        zsl-&gt;tail = x;</span><br><span class="line">    zsl-&gt;length++;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Top-K问题</title>
      <link href="/2024/03/30/TopK%E9%97%AE%E9%A2%98/"/>
      <url>/2024/03/30/TopK%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<p>从n个数中，找到最大（最小）的K个元素</p><p>思路1</p><p>遍历k次数组。找出最大或者最小的k个元素</p><p>时间复杂度O(nk)</p><p>思路2</p><p>全局排序， 对数组进行排序，找出最左边或者最右边的k个元素</p><p>时间复杂度O(nlogn)</p><p>思路3</p><p>局部排序，可以利用冒泡排序，对数组进行k次冒泡</p><p>时间复杂度<code>O(nk)</code></p><p>思路4</p><p>堆排序，先用数组中前k个元素进行堆的建立，然后后面遍历<code>k+1 ~ n-1</code>这些元素，添加到堆中，再对堆进行重排</p><p>时间复杂度<code>O(nlogk)</code></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>【Redis】数据结构-SDS</title>
      <link href="/2024/03/30/%E3%80%90Redis%E3%80%91%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-SDS/"/>
      <url>/2024/03/30/%E3%80%90Redis%E3%80%91%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-SDS/</url>
      
        <content type="html"><![CDATA[<p>SDS：动态简单字符串</p><p>每个<code>sds.h/sdshdr</code>结构表示一个SDS值：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sdshdr</span>&#123;</span></span><br><span class="line">    <span class="comment">// 当前buf数组中已使用的字节数量 = SDS所保存的字符串长度</span></span><br><span class="line">    <span class="type">int</span> len;</span><br><span class="line">    <span class="comment">// 当前buf数组中空闲位置数量</span></span><br><span class="line">    <span class="type">int</span> <span class="built_in">free</span>;</span><br><span class="line">    <span class="type">char</span> buf[];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>char类型的数组，一个位置代表一个字节大小</p></blockquote><ul><li>获取字符串的长度的时间复杂度为O(1)</li><li>SDS的API可以杜绝buf区溢出<ul><li>先检查，再使用</li><li>不够了就扩展</li></ul></li><li>减少了修改字符串带来的内存分配次数<ul><li>空间预分配（修改SDS时）<ul><li>若修改后SDS长度<strong>小于</strong>1MB，则分配总空间为<code>len + len + 1byte</code></li><li>若修改后SDS长度<strong>大于等于</strong>1MB，则分配总空间为<code>len + 1MB + 1byte</code></li></ul></li><li>惰性空间释放<ul><li>缩短字符串之后，空闲地方的大小使用free记录下来</li></ul></li></ul></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【lc】路径总和III</title>
      <link href="/2024/03/29/%E3%80%90lc%E3%80%91%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8CIII/"/>
      <url>/2024/03/29/%E3%80%90lc%E3%80%91%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8CIII/</url>
      
        <content type="html"><![CDATA[<p><strong>题目</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">给定一个二叉树的根节点 root ，和一个整数 targetSum ，求该二叉树里节点值之和等于 targetSum 的 路径 的数目。</span><br><span class="line">路径 不需要从根节点开始，也不需要在叶子节点结束，但是路径方向必须是向下的（只能从父节点到子节点）。</span><br><span class="line"></span><br><span class="line">示例1</span><br><span class="line">输入：root = [10,5,-3,3,2,null,11,3,-2,null,1], targetSum = 8</span><br><span class="line">输出：3</span><br><span class="line">解释：和等于 8 的路径有 3 条，如图所示。</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入：root = [5,4,8,11,null,13,4,7,2,null,null,5,1], targetSum = 22</span><br><span class="line">输出：3</span><br><span class="line"></span><br><span class="line">提示:</span><br><span class="line">二叉树的节点个数的范围是 [0,1000]</span><br><span class="line">-109 &lt;= Node.val &lt;= 109 </span><br><span class="line">-1000 &lt;= targetSum &lt;= 1000 </span><br></pre></td></tr></table></figure><p><strong>思路</strong></p><p>因为是求一段路径的和（类似于一个区间的和），所以可以利用<strong>前缀和</strong>来做。只不过比区间求和要抽象一些。</p><p>题目求的是路径之和为target的路径的数目，我们可以用字典记录<u>路径和</u><strong>出现的次数</strong>，<u>当我们往上回溯的时候，删除当前的区间和即可</u>。</p><p>因为假如遍历到了某节点，那么前缀和字典里记录的<strong>一定是一条线上</strong>的区间和！！</p><p><strong>代码</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">pathSum</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode], target: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        pre = &#123;<span class="number">0</span>: <span class="number">1</span>&#125;</span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">backtrack</span>(<span class="params">root, val</span>):</span><br><span class="line">            <span class="keyword">nonlocal</span> res</span><br><span class="line">            <span class="keyword">if</span> val - target <span class="keyword">in</span> pre:</span><br><span class="line">                res += pre.get(val - target)</span><br><span class="line">            pre[val] = pre.get(val, <span class="number">0</span>) + <span class="number">1</span></span><br><span class="line">            <span class="comment"># 遍历左边和右边</span></span><br><span class="line">            <span class="keyword">if</span> root.left: backtrack(root.left, val + root.left.val)</span><br><span class="line">            <span class="keyword">if</span> root.right: backtrack(root.right, val + root.right.val)</span><br><span class="line">            <span class="comment"># 当向上回去的时候，删除到当前位置的前缀和</span></span><br><span class="line">            pre[val] -= <span class="number">1</span></span><br><span class="line">        backtrack(root, root.val)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【网络】HTTP-HTTPS</title>
      <link href="/2024/03/28/%E7%BD%91%E7%BB%9C-HTTP-HTTPS/"/>
      <url>/2024/03/28/%E7%BD%91%E7%BB%9C-HTTP-HTTPS/</url>
      
        <content type="html"><![CDATA[<h2 id="从输入URL到展示页面-发生了什么事"><a href="#从输入URL到展示页面-发生了什么事" class="headerlink" title="从输入URL到展示页面, 发生了什么事?"></a>从输入URL到展示页面, 发生了什么事?</h2><ol><li>浏览器中输入指定网页的URL</li><li>浏览器通过DNS协议, 获取域名对应的 IP 地址</li><li>浏览器根据 IP 地址和端口号, 向目标服务器发起一个TCP请求.</li><li>浏览器在 TCP 连接上, 向服务器发送一个 HTTP 请求, 请求获取网页内容</li><li>服务器收到 HTTP 请求之后, 处理请求, 并返回 HTTP 响应报文给浏览器</li><li>浏览器收到 HTTP 响应报文之后, 解析响应体中的 HTML 代码, 渲染网页的结构和样式, 同时根据 HTML 中其他资源的 URL, 再次发起 HTTP 请求, 获取这些资源的内容. 直到网页完全加载</li><li>浏览器在不需要和服务器通信时, 可以主动关闭 TCP 链接, 或者等待服务器的关闭你请求.</li></ol><h2 id="HTTP-状态码"><a href="#HTTP-状态码" class="headerlink" title="HTTP 状态码"></a>HTTP 状态码</h2><ul><li>1xx   —  (信息性状态码)             接受的请求正在处理</li><li>2xx   – -  (成功状态码)               请求正常处理完毕</li><li>3xx   —  (重定向状态码)             需要进行附加操作以完成请求</li><li>4xx   —  (客户端错误状态码)     服务器无法处理请求</li><li>5xx   —  (服务端错误状态码)     服务器处理请求出错</li></ul><h2 id="HTTP-和-HTTPS-区别"><a href="#HTTP-和-HTTPS-区别" class="headerlink" title="HTTP 和 HTTPS 区别"></a>HTTP 和 HTTPS 区别</h2><p>从4个角度来说明区别</p><ol><li><p>端口号</p><ol><li>HTTP是<strong>80</strong></li><li>HTTPS是<strong>443</strong></li></ol></li><li><p><strong>URL前缀</strong></p><ol><li>HTTP前缀是<code>http://</code></li><li>HTTPS前缀是<code>https://</code></li></ol></li><li><p>安全性和资源消耗</p></li><li><p>HTTP协议运行在TCP之上, 内容是明文, 会被网络上节点获取和查看, 因此非常不安全</p></li><li><p>HTTPS运行的是<strong>加密的 HTTP 协议</strong>, 它在 HTTP 和 TCP 之间<strong>增加了一个SSL&#x2F;TLS 层.</strong> 所有的 HTTP通信内容都会被加密 </p></li><li><p>SEO – 搜索引擎优化</p></li><li><p><strong>搜索引擎通常更青睐使用 HTTPS 的网站</strong>, 因为更安全.. 使用 HTTPS的网站在搜索结果中会被优先展示…</p></li></ol><p>如果仅仅使用HTTP协议进行交流的话，内容很容易被窃取。</p><p>用对称加密</p><blockquote><ol><li>服务器将密钥A发给浏览器</li><li>浏览器用密钥A对数据进行加密，将加密后的数据发送给服务器</li><li>服务器用密钥A进行解密</li></ol><p>但是这样操作有很大的问题，如何防止第三方坏人窃取到密钥A呢</p></blockquote><p>用非对称加密</p><blockquote><p>一对公钥和私钥</p><p>公钥加密的数据只能由私钥解密</p><p>私钥加密的数据只能由公钥解密  </p><ol><li>服务器将自己的公钥A发送给浏览器</li><li>浏览器生成一个随机数（会话密钥），再用公钥A进行加密，发送给服务器</li><li>服务器用自己的私钥对数据进行解密，得到会话密钥</li><li>之后双方用会话密钥进行交流。</li></ol><p>但是这样仍然有些问题：浏览器如何确定服务器发来的公钥是正确的呢？也就是说怎么确保浏览器发来的公钥没有被掉包呢？</p></blockquote><p>证书+数字签名</p><blockquote><p>1231</p><ol><li>服务器把自己的公钥、使用者、颁发者…等等信息集合发送给权威的签名机构CA</li><li><strong>CA再用自己的私钥</strong>对这些数据进行加密得到密文（称之为<strong>签名</strong>），然后将<strong>密文和原始数据</strong>放在一起发给服务器管理员，这就是<strong>TLS证书</strong>。</li><li>服务器将自己的证书发给浏览器</li><li>浏览器得到证书后，用CA机构的公钥进行解密，如果解密后的内容和证书其他部分一样，则通过验证。</li><li>验证通过后，则可以放心大胆地使用证书上的服务器公钥了。</li><li>用证书上的服务器公钥生成一个会话密钥，发送给服务器，之后双方就可以通过会话密钥进行通信加密了。</li></ol><p>如何保证CA机构的公钥是正确的呢？或者说如何保证这个CA机构是可信任的呢？</p><p>答案就是提前将可信任的权威CA机构的信息内置到操作系统或者浏览器中。</p></blockquote><p>两个讲解https安全性机制的视频</p><blockquote><p> <a href="https://www.bilibili.com/video/BV1uY4y1D7Ng/">https://www.bilibili.com/video/BV1uY4y1D7Ng/</a></p><p><a href="https://www.bilibili.com/video/BV1TP411G7wb/">https://www.bilibili.com/video/BV1TP411G7wb/</a></p></blockquote><h2 id="SSL-TLS-协议"><a href="#SSL-TLS-协议" class="headerlink" title="SSL&#x2F;TLS 协议"></a>SSL&#x2F;TLS 协议</h2><h3 id="SSL-和-TLS-区别"><a href="#SSL-和-TLS-区别" class="headerlink" title="SSL 和 TLS 区别"></a>SSL 和 TLS 区别</h3><p>没有太大区别, TLS 是基于 SSL 之上的., 是 SSL 的升级版..</p><h3 id="SSL-TLS-工作原理"><a href="#SSL-TLS-工作原理" class="headerlink" title="SSL &#x2F; TLS 工作原理"></a>SSL &#x2F; TLS 工作原理</h3><h4 id="非对称加密-SSL-TLS握手协议使用"><a href="#非对称加密-SSL-TLS握手协议使用" class="headerlink" title="非对称加密(SSL&#x2F;TLS握手协议使用"></a>非对称加密(SSL&#x2F;TLS握手协议使用</h4><p>公钥用来加密</p><p>私钥用来解密</p><p>单向陷门函数 </p><h4 id="对称加密-SSL-TLS握手协议结束之后使用"><a href="#对称加密-SSL-TLS握手协议结束之后使用" class="headerlink" title="对称加密(SSL&#x2F;TLS握手协议结束之后使用"></a>对称加密(SSL&#x2F;TLS握手协议结束之后使用</h4><p>通信双方具有相同的密钥, 可以用同一个密钥对信息进行加密解密</p><h4 id="非对称加密和对称加密一起使用"><a href="#非对称加密和对称加密一起使用" class="headerlink" title="非对称加密和对称加密一起使用"></a>非对称加密和对称加密一起使用</h4><p>SSL和TLS在建立连接的过程中，实际上同时使用了对称加密和非对称加密两种方式。</p><p>在握手阶段，它们<strong>使用非对称加密完成密钥的交换</strong>。客户端生成一个<strong>随机的会话秘钥</strong>，使用服务器的公钥加密后，发送给服务器。服务器使用自己的私钥解密收到的信息，<strong>得到会话密钥</strong>。这个过程保证了会话密钥在传输过程中的安全，无法被第三方窃取。</p><p>一旦<strong>会话秘钥</strong>交换成功，服务器和客户端的<strong>后续通信将会使用这个秘钥进行对称加密</strong>。因为对比非对称加密，对称加密更为高效，适合大量数据的传输。</p><p>总结来说，SSL和TLS在建立连接的过程中，<strong>首先使用非对称加密交换秘钥</strong>，然后<strong>使用对称加密交换数据</strong>，既保证了<strong>安全性</strong>，又保证了<strong>效率</strong>。</p><h4 id="证书的作用"><a href="#证书的作用" class="headerlink" title="证书的作用"></a>证书的作用</h4><ol><li><p>确认网站身份：当你访问一个使用 HTTPS 的网站时，这个网站会把它的证书发送给你的浏览器。这个证书中包含很多信息，包括证书的<strong>颁发者</strong>、证书的<strong>拥有者</strong>（也就是这个网站）、证书的<strong>有效期</strong>以及<strong>公钥</strong>等等。你的浏览器会查看这个证书，确认这个证书是由受信任的证书颁发机构颁发的，并且证书的拥有者就是你正在访问的那个网站。这个过程可以<strong>防止你误入假冒网站，增加安全性</strong>。</p></li><li><p>加密通信：在使用 HTTPS 的通信过程中，<strong>信息的发送者和接收者都会用到证书中包含的公钥</strong>和<strong>自己的私钥</strong>进行<strong>非对称加密</strong>，以此保证传输的信息不会被第三方轻易窃听或篡改。你的浏览器会使用证书中的公钥对信息进行加密，只有网站持有的相应私钥才能解密。这样，即使信息在传输过程中被截取，由于没有正确的私钥，也无法被解读。这个过程可以保证数据的机密性。</p></li><li><p>公钥加密、私钥解密</p></li><li><p>私钥签名、公钥验签</p></li></ol><h3 id="TLS握手步骤："><a href="#TLS握手步骤：" class="headerlink" title="TLS握手步骤："></a>TLS握手步骤：</h3><ol><li><strong>客户端问候</strong>：客户端向服务器发送<code>“client hello” + 支持的SSL版本 + 随机数A</code></li><li><strong>服务器问候</strong>：服务器收到之后，向客户端发送<code>“server hello” + SSL证书 + 随机数B</code> </li><li><strong>身份验证</strong>：客户端验证服务器的<code>SSL证书</code>是否合法</li><li><strong>预主密钥</strong>：验证合法之后，客户端向服务器发送一串<code>预主密钥（premaster secret）</code>（预主密钥使用服务器<code>SSL证书</code>里的公钥进行加密）</li><li><strong>服务器使用私钥</strong>：服务器收到预主密钥之后，用自己的私钥进行解密。</li><li><strong>生成会话密钥</strong>：客户端和服务器使用<code>随机数A、随机数B、预主密钥</code>生成一串<code>会话密钥</code></li><li><strong>客户端就绪</strong>：客户端发送一条“已完成”消息，该消息用会话密钥加密</li><li><strong>服务端就绪</strong>：服务器发送一条“已完成”消息，该消息用会话密钥加密</li><li><strong>实现安全的对称加密</strong>：至此，已经完成握手，后续双方可以使用会话密钥进行传递信息了</li></ol><h2 id="HTTP不同版本"><a href="#HTTP不同版本" class="headerlink" title="HTTP不同版本"></a>HTTP不同版本</h2><h3 id="HTTP1-1-相对于-HTTP1-0-的主要改进："><a href="#HTTP1-1-相对于-HTTP1-0-的主要改进：" class="headerlink" title="HTTP1.1 相对于 HTTP1.0 的主要改进："></a>HTTP1.1 相对于 HTTP1.0 的主要改进：</h3><ol><li><p><strong>长连接</strong>（Keep-Alive）：HTTP1.0 默认使用短连接即每次请求都要创建一个新的连接，这种方式在网络传输中存在很大的消耗。而HTTP1.1默认使用长连接，可以在一个TCP连接中发送多个HTTP请求和响应，显著提高了传输效率。 </p></li><li><p><strong>管道机制</strong>（Pipelining）：可在同一连接中，按顺序同时发送多个请求，而不必等待上一个请求的响应，进一步提高了传输效率。 </p></li><li><p><strong>支持Host字段</strong>：在HTTP1.1中，如果一个Web服务器支持多个域名，那么它可以通过Host字段来识别客户端请求的是哪个域名下的内容。 </p></li><li><p><strong>新增的状态码、方法</strong>等：例如新增了<strong>OPTIONS、DELETE</strong>等请求方法，新增了many个状态码。 </p></li><li><p>状态码</p></li><li><p>100,  请求大资源的预热</p></li><li><p>409,  请求于当前资源规定冲突</p></li><li><p>410…   资源被永久转移,   且没有任何已知的转发地址</p></li></ol><h3 id="HTTP1-x的缺点"><a href="#HTTP1-x的缺点" class="headerlink" title="HTTP1.x的缺点"></a>HTTP1.x的缺点</h3><p>任何事物的更新都是为了弥补或修复上个版本的某些问题，那么我们来看看HTTP1.x都有哪些缺点以至于我们要使用HTTP2.0。</p><p>HTTP1.x有以下几个主要缺点：</p><ol><li>HTTP&#x2F;1.0一次只允许在<strong>一个TCP连接</strong>上发起一个请求，HTTP&#x2F;1.1使用的流水线技术也只能部分处理请求并发，仍然会存在队列头阻塞问题，因此客户端在需要发起多次请求时，通常会采用建立多连接来减少延迟。</li><li><strong>单向请求</strong>，只能由客户端发起。</li><li>请求报文与响应报文首部信息冗余量大。</li><li>数据未压缩，导致数据的传输量大。</li></ol><h3 id="HTTP2-0-相对于-HTTP1-1-的主要改进："><a href="#HTTP2-0-相对于-HTTP1-1-的主要改进：" class="headerlink" title="HTTP2.0 相对于 HTTP1.1 的主要改进："></a>HTTP2.0 相对于 HTTP1.1 的主要改进：</h3><ol><li><p><strong>二进制分帧</strong>：在HTTP2.0中，所有传输的信息都被封装在“帧”里，每个帧的头部包括了该帧怎么被处理和发送的元信息。所有的帧都由二进制组成。 </p></li><li><p>帧头frame header       帧体frame payload</p></li><li><p>帧头frame header</p></li><li><p>该帧怎么被处理和发送的元信息:  帧类型…….流标识符……..长度………</p></li><li><p><strong>多路复用</strong>：在一个TCP连接中可以传输多个HTTP请求&#x2F;响应，之间互不干扰。 </p></li><li><p>帧frame    流stream</p></li><li><p>帧是最小数据单位, 每个帧会标识出该帧属于哪个流, 流是由多个帧组成的数据流</p></li><li><p>TCP 链接中存在多个流, 即可以同时发送多个请求, 对端可以通过帧的流标识符来确定该帧属于哪个请求…  在客户端,这些帧乱序发送, 到对端之后再通过帧首部的流标识符重新组装. …可以避免HTTP旧版本的对头阻塞问题, 极大提高了传输性能… </p></li><li><p><strong>请求优先级</strong>：HTTP2.0可以设置请求的优先级，优先级高的请求会优先得到处理。 </p></li><li><p><strong>服务器推送</strong>：HTTP2.0新增的一个功能，服务器可以在客户端还没请求之前主动发送资源。 </p></li><li><p><strong>首部压缩</strong>：HTTP1.1中，请求和响应的首部未经压缩就发送，导致数据冗余。HTTP2.0引入了HPACK算法进行首部压缩，减小了数据的传输量。</p></li></ol><h3 id="spdy协议"><a href="#spdy协议" class="headerlink" title="spdy协议"></a>spdy协议</h3><p>SPDY协议是Google公司开发的一种应用层网络协议。SPDY旨在<strong>强化HTTP协议</strong>。</p><p>HTTP协议实现简单，被广泛应用于Internet上，但是随着Web服务日趋复杂和庞大，HTTP的问题也更加明显，如打开一个HTTPS网页需要多轮的往返回传输，这就导致复杂的网页加载速度过慢。因此，Google开发SPDY来<strong>提高性能</strong>。</p><p>SPDY协议具有以下几个主要特点：</p><ol><li><strong>支持多路复用</strong>：SPDY允许在一个TCP连接中，并行请求或响应多个内容，大大提高了网络传输的利用率。 </li><li><strong>支持优先级队列</strong>：SPDY允许为每一个请求设置优先级，让重要的请求优先得到服务器的响应。 </li><li><strong>HTTP报头压缩</strong>：SPDY协议以二进制方式进行编码，通过压缩HTTP请求头数据，减小了数据传输的大小，从而达到加速的效果。 </li><li><strong>服务器推送</strong>：在客户端还没有请求之前，服务器就可以将对应的数据推送给客户端，进一步提升了加载速度。</li></ol><p>Google开发SPDY的目的是为了解决HTTP协议在实际使用中暴露出的问题，减少网页加载时间，提高用户体验。事实上，SPDY协议在一定程度上已经实现了这个目标，HTTP&#x2F;2协议的许多新特性就是基于SPDY协议的。 </p>]]></content>
      
      
      
        <tags>
            
            <tag> 网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Redis】缓存穿透、击穿、雪崩</title>
      <link href="/2024/03/01/%E3%80%90Redis%E3%80%91%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F%E3%80%81%E5%87%BB%E7%A9%BF%E3%80%81%E9%9B%AA%E5%B4%A9/"/>
      <url>/2024/03/01/%E3%80%90Redis%E3%80%91%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F%E3%80%81%E5%87%BB%E7%A9%BF%E3%80%81%E9%9B%AA%E5%B4%A9/</url>
      
        <content type="html"><![CDATA[<p>可以这样记忆：</p><p><strong>穿透</strong>：透了，就是redis和db都穿了</p><p>击穿：仅仅穿了redis，db没穿</p><p><strong>雪崩</strong>：雪山崩塌了，大量东西同时g了</p><h3 id="穿透"><a href="#穿透" class="headerlink" title="穿透"></a><strong>穿透</strong></h3><p>读取数据的时候，redis和db都没有。</p><h4 id="如何解决呢？"><a href="#如何解决呢？" class="headerlink" title="如何解决呢？"></a>如何解决呢？</h4><ol><li>线程第一次读到db没有的时候，将一个null值放入redis中，以防后续db压力过大</li><li>使用布隆过滤器快速判断数据是否存在。“不存在一定不存在，存在可能不存在！”</li></ol><p>布隆过滤器的构建流程</p><ol><li>使用n个哈希函数分别对数据做哈希运算，得到n个哈希值</li><li>将那n个哈希值对位图数组的长度取模，得到每个索引下标</li><li>将每个索引下表值置为1</li></ol><h3 id="击穿"><a href="#击穿" class="headerlink" title="击穿"></a>击穿</h3><p>热点数据redis没有，db有</p><h4 id="解决方案："><a href="#解决方案：" class="headerlink" title="解决方案："></a>解决方案：</h4><ol><li><p>使用互斥锁。将热点数据加锁，然后去db将数据恢复到redis中</p></li><li><p>使用逻辑过期</p><ol><li><p>key是通过原始数据创建的，value是下面这个RedisData类所创建的对象</p></li><li><pre><code class="java">public class RedisData &#123;    private LocalDateTime expireTime;    private Object data;&#125;</code></pre></li><li><p>这样就实现了在应用层面实现过期。当发现逻辑过期的时候，我们创建一个锁，锁住这个数据，然后fork一个新的进程来去从db中恢复数据到redis，最后释放锁即可。</p></li></ol></li></ol><h3 id="雪崩"><a href="#雪崩" class="headerlink" title="雪崩"></a>雪崩</h3><p>redis大量数据同时过期或者redis故障宕机，造成db压力过大</p><h4 id="解决方案：-1"><a href="#解决方案：-1" class="headerlink" title="解决方案："></a>解决方案：</h4><h5 id="大量数据同时过期："><a href="#大量数据同时过期：" class="headerlink" title="大量数据同时过期："></a><strong>大量数据同时过期：</strong></h5><p><strong>大量数据同时过期</strong>的解决方案：</p><ol><li><p><strong>均匀</strong>设置过期时间：在对缓存数据设置过期时间的时候，加上一个随机数</p></li><li><p>当一个线程访问到redis没有的数据的时候，则<strong>上一把互斥锁</strong>，保证同一时间只有一个请求来<strong>构建缓存</strong>。</p><ol><li>未能获取到锁的请求，要么<strong>等待锁释放之后重新读缓存</strong>，要么<strong>返回空值或者默认值</strong></li><li>ps：实现互斥锁的时候，最好可以设置一个超时时间。不然第一个请求拿到了锁，万一发生了某些意外一直阻塞，一直不释放锁，这时其他请求也一直拿不到锁</li></ol></li><li><p><u><strong>后台更新缓存</strong></u>：缓存不设置有效期，将缓存更新的工作交由后台线程定时更新。</p><ol><li>两种方式：<ol><li>后台线程不断检测缓存是否有效。（<strong>用户体验不好</strong>，检测的时候会阻塞主线程处理数据）</li><li>业务线程发现数据失效之后，通过消息队列发送一条消息通知后台线程更新缓存。<ol><li>在业务刚上线时，最好提前把数据存入缓存中，而不是等到用户来访问了再存，这叫做“**<u>缓存预热</u>**”</li></ol></li></ol></li></ol></li></ol><h5 id="服务宕机"><a href="#服务宕机" class="headerlink" title="服务宕机"></a><strong>服务宕机</strong></h5><p>服务宕机解决方案：</p><ol><li>服务熔断或请求限流机制<ol><li>启用服务熔断机制，<strong>暂停业务应用对缓存服务的访问</strong>，直接返回错误。（虽然但是，会造成全部业务应用无法正常工作！）</li><li>请求限流机制：只将少部分请求发送到db进行处理，再多的请求就直接拒绝！等redis恢复正常并且把缓存预热完毕之后，再解除限流机制。</li></ol></li><li>构建Redis缓存高可靠集群<ol><li>“服务熔断或请求限流机制”都是雪崩发生之后的应对方案。。。不过我们可以防范于未然，通过主从节点的方式构建高可靠的集群。<ol><li>主节点服务宕机了，可以直接重新选举一个主节点，继续对外提供服务，使得外界应用无感。</li></ol></li></ol></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【lc】查询球队积分</title>
      <link href="/2024/01/31/%E3%80%90lc%E3%80%91%E6%9F%A5%E8%AF%A2%E7%90%83%E9%98%9F%E7%A7%AF%E5%88%86/"/>
      <url>/2024/01/31/%E3%80%90lc%E3%80%91%E6%9F%A5%E8%AF%A2%E7%90%83%E9%98%9F%E7%A7%AF%E5%88%86/</url>
      
        <content type="html"><![CDATA[<p>题目</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">表: Teams</span><br><span class="line">+---------------+----------+</span><br><span class="line">| Column Name   | Type     |</span><br><span class="line">+---------------+----------+</span><br><span class="line">| team_id       | int      |</span><br><span class="line">| team_name     | varchar  |</span><br><span class="line">+---------------+----------+</span><br><span class="line">team_id 是该表具有唯一值的列。</span><br><span class="line">表中的每一行都代表一支独立足球队。</span><br><span class="line"></span><br><span class="line">表: Matches</span><br><span class="line">+---------------+---------+</span><br><span class="line">| Column Name   | Type    |</span><br><span class="line">+---------------+---------+</span><br><span class="line">| match_id      | int     |</span><br><span class="line">| host_team     | int     |</span><br><span class="line">| guest_team    | int     | </span><br><span class="line">| host_goals    | int     |</span><br><span class="line">| guest_goals   | int     |</span><br><span class="line">+---------------+---------+</span><br><span class="line">match_id 是该表具有唯一值的列。</span><br><span class="line">表中的每一行都代表一场已结束的比赛。</span><br><span class="line">比赛的主客队分别由它们自己的 id 表示，他们的进球由 host_goals 和 guest_goals 分别表示。</span><br><span class="line"> </span><br><span class="line">你希望在所有比赛之后计算所有球队的比分。积分奖励方式如下:</span><br><span class="line">如果球队赢了比赛(即比对手进更多的球)，就得 3 分。</span><br><span class="line">如果双方打成平手(即，与对方得分相同)，则得 1 分。</span><br><span class="line">如果球队输掉了比赛(例如，比对手少进球)，就 不得分 。</span><br><span class="line">编写解决方案，以找出每个队的 team_id，team_name 和 num_points。</span><br><span class="line">返回的结果根据 num_points 降序排序，如果有两队积分相同，那么这两队按 team_id  升序排序。</span><br><span class="line">返回结果格式如下。</span><br><span class="line"></span><br><span class="line">示例 1:</span><br><span class="line">输入：</span><br><span class="line">Teams table:</span><br><span class="line">+-----------+--------------+</span><br><span class="line">| team_id   | team_name    |</span><br><span class="line">+-----------+--------------+</span><br><span class="line">| 10        | Leetcode FC  |</span><br><span class="line">| 20        | NewYork FC   |</span><br><span class="line">| 30        | Atlanta FC   |</span><br><span class="line">| 40        | Chicago FC   |</span><br><span class="line">| 50        | Toronto FC   |</span><br><span class="line">+-----------+--------------+</span><br><span class="line">Matches table:</span><br><span class="line">+------------+--------------+---------------+-------------+--------------+</span><br><span class="line">| match_id   | host_team    | guest_team    | host_goals  | guest_goals  |</span><br><span class="line">+------------+--------------+---------------+-------------+--------------+</span><br><span class="line">| 1          | 10           | 20            | 3           | 0            |</span><br><span class="line">| 2          | 30           | 10            | 2           | 2            |</span><br><span class="line">| 3          | 10           | 50            | 5           | 1            |</span><br><span class="line">| 4          | 20           | 30            | 1           | 0            |</span><br><span class="line">| 5          | 50           | 30            | 1           | 0            |</span><br><span class="line">+------------+--------------+---------------+-------------+--------------+</span><br><span class="line">输出：</span><br><span class="line">+------------+--------------+---------------+</span><br><span class="line">| team_id    | team_name    | num_points    |</span><br><span class="line">+------------+--------------+---------------+</span><br><span class="line">| 10         | Leetcode FC  | 7             |</span><br><span class="line">| 20         | NewYork FC   | 3             |</span><br><span class="line">| 50         | Toronto FC   | 3             |</span><br><span class="line">| 30         | Atlanta FC   | 1             |</span><br><span class="line">| 40         | Chicago FC   | 0             |</span><br><span class="line">+------------+--------------+---------------+</span><br></pre></td></tr></table></figure><p>思路</p><p>链接两个表，然后针对每一种情况进行判断</p><p>代码</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- # Write your MySQL query statement below</span></span><br><span class="line"><span class="keyword">SELECT</span> </span><br><span class="line">    team_id, </span><br><span class="line">    team_name,</span><br><span class="line">    IFNULL( <span class="built_in">SUM</span>(  # 这里一定要注意，SUM后面的括号要紧挨着SUM关键字，否则会报错，也就是只能<span class="built_in">SUM</span>(),不能写成<span class="built_in">SUM</span> ()</span><br><span class="line">            <span class="keyword">CASE</span></span><br><span class="line">                <span class="keyword">WHEN</span> team_id <span class="operator">=</span> host_team <span class="keyword">AND</span> host_goals <span class="operator">&gt;</span> guest_goals <span class="keyword">THEN</span> <span class="number">3</span></span><br><span class="line">                <span class="keyword">WHEN</span> team_id <span class="operator">=</span> guest_team <span class="keyword">AND</span> host_goals <span class="operator">&lt;</span> guest_goals <span class="keyword">THEN</span> <span class="number">3</span></span><br><span class="line">                <span class="keyword">WHEN</span> host_goals <span class="operator">=</span> guest_goals <span class="keyword">THEN</span> <span class="number">1</span></span><br><span class="line">                <span class="keyword">ELSE</span> <span class="number">0</span></span><br><span class="line">            <span class="keyword">END</span></span><br><span class="line">            ), <span class="number">0</span>) <span class="keyword">AS</span> num_points</span><br><span class="line"><span class="keyword">FROM</span> Teams t</span><br><span class="line"><span class="keyword">LEFT</span> <span class="keyword">JOIN</span> <span class="keyword">Matches</span> m</span><br><span class="line"><span class="keyword">ON</span> t.team_id <span class="operator">=</span> m.host_team <span class="keyword">OR</span> t.team_id <span class="operator">=</span> m.guest_team</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> team_id</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> num_points <span class="keyword">DESC</span>, team_id</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【lc】计算布尔表达式的值</title>
      <link href="/2024/01/31/%E3%80%90lc%E3%80%91%E8%AE%A1%E7%AE%97%E5%B8%83%E5%B0%94%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9A%84%E5%80%BC/"/>
      <url>/2024/01/31/%E3%80%90lc%E3%80%91%E8%AE%A1%E7%AE%97%E5%B8%83%E5%B0%94%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9A%84%E5%80%BC/</url>
      
        <content type="html"><![CDATA[<p>题目</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">表 Variables:</span><br><span class="line">+---------------+---------+</span><br><span class="line">| Column Name   | Type    |</span><br><span class="line">+---------------+---------+</span><br><span class="line">| name          | varchar |</span><br><span class="line">| value         | int     |</span><br><span class="line">+---------------+---------+</span><br><span class="line">在 SQL 中，name 是该表主键.</span><br><span class="line">该表包含了存储的变量及其对应的值.</span><br><span class="line"> </span><br><span class="line">表 Expressions:</span><br><span class="line">+---------------+---------+</span><br><span class="line">| Column Name   | Type    |</span><br><span class="line">+---------------+---------+</span><br><span class="line">| left_operand  | varchar |</span><br><span class="line">| operator      | enum    |</span><br><span class="line">| right_operand | varchar |</span><br><span class="line">+---------------+---------+</span><br><span class="line">在 SQL 中，(left_operand, operator, right_operand) 是该表主键.</span><br><span class="line">该表包含了需要计算的布尔表达式.</span><br><span class="line">operator 是枚举类型, 取值于(&#x27;&lt;&#x27;, &#x27;&gt;&#x27;, &#x27;=&#x27;)</span><br><span class="line">left_operand 和 right_operand 的值保证存在于 Variables 表单中.</span><br><span class="line"> </span><br><span class="line">计算表 Expressions 中的布尔表达式。</span><br><span class="line">返回的结果表 无顺序要求 。</span><br><span class="line">结果格式如下例所示。</span><br><span class="line"></span><br><span class="line">示例 1</span><br><span class="line">输入：</span><br><span class="line">Variables 表:</span><br><span class="line">+------+-------+</span><br><span class="line">| name | value |</span><br><span class="line">+------+-------+</span><br><span class="line">| x    | 66    |</span><br><span class="line">| y    | 77    |</span><br><span class="line">+------+-------+</span><br><span class="line">Expressions 表:</span><br><span class="line">+--------------+----------+---------------+</span><br><span class="line">| left_operand | operator | right_operand |</span><br><span class="line">+--------------+----------+---------------+</span><br><span class="line">| x            | &gt;        | y             |</span><br><span class="line">| x            | &lt;        | y             |</span><br><span class="line">| x            | =        | y             |</span><br><span class="line">| y            | &gt;        | x             |</span><br><span class="line">| y            | &lt;        | x             |</span><br><span class="line">| x            | =        | x             |</span><br><span class="line">+--------------+----------+---------------+</span><br><span class="line">输出:</span><br><span class="line">+--------------+----------+---------------+-------+</span><br><span class="line">| left_operand | operator | right_operand | value |</span><br><span class="line">+--------------+----------+---------------+-------+</span><br><span class="line">| x            | &gt;        | y             | false |</span><br><span class="line">| x            | &lt;        | y             | true  |</span><br><span class="line">| x            | =        | y             | false |</span><br><span class="line">| y            | &gt;        | x             | true  |</span><br><span class="line">| y            | &lt;        | x             | false |</span><br><span class="line">| x            | =        | x             | true  |</span><br><span class="line">+--------------+----------+---------------+-------+</span><br><span class="line">解释：</span><br><span class="line">如上所示, 你需要通过使用 Variables 表来找到 Expressions 表中的每一个布尔表达式的值.</span><br></pre></td></tr></table></figure><p>使用<code>left join</code>进行链接</p><p>因为<code>variables</code>表要匹配<code>expressions</code>表中的某个记录的话，需要同时匹配<code>left_operand</code>和<code>right_operand</code></p><p>因此，需要链接两次<code>expressions</code>表</p><p>代码</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"># Write your MySQL query statement below</span><br><span class="line"><span class="keyword">SELECT</span> </span><br><span class="line">    left_operand,</span><br><span class="line">    operator, </span><br><span class="line">    right_operand,</span><br><span class="line">    (</span><br><span class="line">        <span class="keyword">CASE</span></span><br><span class="line">            <span class="keyword">WHEN</span> E.operator <span class="operator">=</span> <span class="string">&#x27;&gt;&#x27;</span> <span class="operator">&amp;&amp;</span> V1.value <span class="operator">&gt;</span> V2.value <span class="keyword">THEN</span> <span class="string">&#x27;true&#x27;</span> # <span class="literal">true</span>和<span class="literal">false</span>要加上引号，否则结果会变为<span class="number">1</span>和<span class="number">0</span></span><br><span class="line">            <span class="keyword">WHEN</span> E.operator <span class="operator">=</span> <span class="string">&#x27;=&#x27;</span> <span class="operator">&amp;&amp;</span> V1.value <span class="operator">=</span> V2.value <span class="keyword">THEN</span> <span class="string">&#x27;true&#x27;</span></span><br><span class="line">            <span class="keyword">WHEN</span> E.operator <span class="operator">=</span> <span class="string">&#x27;&lt;&#x27;</span> <span class="operator">&amp;&amp;</span> V1.value <span class="operator">&lt;</span> V2.value <span class="keyword">THEN</span> <span class="string">&#x27;true&#x27;</span></span><br><span class="line">        <span class="keyword">ELSE</span></span><br><span class="line">            <span class="string">&#x27;false&#x27;</span></span><br><span class="line">        <span class="keyword">END</span> # 注意一定不要丢掉这个<span class="keyword">END</span>，否则会报语法错误</span><br><span class="line">    ) <span class="keyword">AS</span> <span class="keyword">value</span></span><br><span class="line"><span class="keyword">FROM</span> Expressions E </span><br><span class="line"><span class="keyword">LEFT</span> <span class="keyword">JOIN</span> Variables V1 <span class="keyword">ON</span> E.left_operand <span class="operator">=</span> V1.name</span><br><span class="line"><span class="keyword">LEFT</span> <span class="keyword">JOIN</span> Variables V2 <span class="keyword">ON</span> E.right_operand <span class="operator">=</span> V2.name</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【lc】前K个高频元素</title>
      <link href="/2024/01/30/%E3%80%90lc%E3%80%91%E5%89%8DK%E4%B8%AA%E9%AB%98%E9%A2%91%E5%85%83%E7%B4%A0/"/>
      <url>/2024/01/30/%E3%80%90lc%E3%80%91%E5%89%8DK%E4%B8%AA%E9%AB%98%E9%A2%91%E5%85%83%E7%B4%A0/</url>
      
        <content type="html"><![CDATA[<p>题目</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">给你一个整数数组 nums 和一个整数 k ，请你返回其中出现频率前 k 高的元素。你可以按 任意顺序 返回答案。</span><br><span class="line"></span><br><span class="line">示例 1:</span><br><span class="line">输入: nums = [1,1,1,2,2,3], k = 2</span><br><span class="line">输出: [1,2]</span><br><span class="line"></span><br><span class="line">示例 2:</span><br><span class="line">输入: nums = [1], k = 1</span><br><span class="line">输出: [1]</span><br><span class="line"> </span><br><span class="line">提示：</span><br><span class="line">1 &lt;= nums.length &lt;= 105</span><br><span class="line">k 的取值范围是 [1, 数组中不相同的元素的个数]</span><br><span class="line">题目数据保证答案唯一，换句话说，数组中前 k 个高频元素的集合是唯一的</span><br><span class="line"> </span><br><span class="line">进阶：你所设计算法的时间复杂度 必须 优于 O(n log n) ，其中 n 是数组大小。</span><br></pre></td></tr></table></figure><p>思路</p><p>利用堆排序，先将前k个元素建成一个堆，然后遍历后面的元素，重入堆，重建堆</p><blockquote><p><code>Counter</code>函数用法</p><p>数组 <code>a = [6,6,6,3,3,1,2,5,5,5]</code></p><p><code>Counter(a) = [ (6 : 3), (5 : 3), (3 : 2), (1 : 1), (2 : 1)]</code>     —&gt;     一个list，元素是一个元组：（元素，出现次数）</p></blockquote><blockquote><p>python里面建堆，默认都是小根堆</p><p>入堆操作：<code>heappush(heap, x)</code></p><p>出堆操作：<code>heappop(heap)</code>，出的是最小值，假如堆中元素是元组，则根据元组的第一个元素来确定顺序</p></blockquote><p>代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">topKFrequent</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], k: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        <span class="comment"># 得到一个数组，每个元素是一个元组：(x出现次数, x)</span></span><br><span class="line">        num_list = [(cnt, num) <span class="keyword">for</span> num, cnt <span class="keyword">in</span> Counter(nums).items()]</span><br><span class="line">        <span class="comment"># 先取前k个元素</span></span><br><span class="line">        heap = num_list[:k]</span><br><span class="line">        heapify(heap)</span><br><span class="line">        <span class="keyword">for</span> item <span class="keyword">in</span> num_list[k:]:</span><br><span class="line">            <span class="comment"># 将当前元组元素item加入堆中</span></span><br><span class="line">            heappush(heap, item)</span><br><span class="line">            <span class="comment"># 将堆中cnt最小的元素抛出</span></span><br><span class="line">            heappop(heap)</span><br><span class="line">        <span class="keyword">return</span> [v <span class="keyword">for</span> k, v <span class="keyword">in</span> heap]</span><br></pre></td></tr></table></figure><p>时间复杂度为<code>O(n+nlogk)</code></p><p>在<code>n</code>远大于<code>k</code>的情况下，时间复杂度为<code>O(nlogk)</code></p>]]></content>
      
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Java集合】HashMap源码</title>
      <link href="/2023/10/28/%E3%80%90Java%E9%9B%86%E5%90%88%E3%80%91HashMap%E6%BA%90%E7%A0%81/"/>
      <url>/2023/10/28/%E3%80%90Java%E9%9B%86%E5%90%88%E3%80%91HashMap%E6%BA%90%E7%A0%81/</url>
      
        <content type="html"><![CDATA[<p>类属性</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HashMap</span>&lt;K,V&gt; <span class="keyword">extends</span> <span class="title class_">AbstractMap</span>&lt;K,V&gt; <span class="keyword">implements</span> <span class="title class_">Map</span>&lt;K,V&gt;, Cloneable, Serializable &#123;</span><br><span class="line">    <span class="comment">// 序列号</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">362498820763181265L</span>;</span><br><span class="line">    <span class="comment">// 默认的初始容量是16</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">DEFAULT_INITIAL_CAPACITY</span> <span class="operator">=</span> <span class="number">1</span> &lt;&lt; <span class="number">4</span>;</span><br><span class="line">    <span class="comment">// 最大容量</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAXIMUM_CAPACITY</span> <span class="operator">=</span> <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</span><br><span class="line">    <span class="comment">// 默认的负载因子</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">float</span> <span class="variable">DEFAULT_LOAD_FACTOR</span> <span class="operator">=</span> <span class="number">0.75f</span>;</span><br><span class="line">    <span class="comment">// 当桶(bucket)上的结点数大于等于这个值时会转成红黑树</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">TREEIFY_THRESHOLD</span> <span class="operator">=</span> <span class="number">8</span>;</span><br><span class="line">    <span class="comment">// 当桶(bucket)上的结点数小于等于这个值时树转链表</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">UNTREEIFY_THRESHOLD</span> <span class="operator">=</span> <span class="number">6</span>;</span><br><span class="line">    <span class="comment">// 桶中结构转化为红黑树对应的table的最小容量</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MIN_TREEIFY_CAPACITY</span> <span class="operator">=</span> <span class="number">64</span>;</span><br><span class="line">    <span class="comment">// 存储元素的数组，总是2的幂次倍</span></span><br><span class="line">    <span class="keyword">transient</span> Node&lt;k,v&gt;[] table;</span><br><span class="line">    <span class="comment">// 存放具体元素的集</span></span><br><span class="line">    <span class="keyword">transient</span> Set&lt;map.entry&lt;k,v&gt;&gt; entrySet;</span><br><span class="line">    <span class="comment">// 存放元素的个数，注意这个不等于数组的长度。</span></span><br><span class="line">    <span class="keyword">transient</span> <span class="type">int</span> size;</span><br><span class="line">    <span class="comment">// 每次扩容和更改map结构的计数器</span></span><br><span class="line">    <span class="keyword">transient</span> <span class="type">int</span> modCount;</span><br><span class="line">    <span class="comment">// 阈值(容量*负载因子) 当实际大小超过阈值时，会进行扩容</span></span><br><span class="line">    <span class="type">int</span> threshold;</span><br><span class="line">    <span class="comment">// 负载因子</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">float</span> loadFactor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Node类节点</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 继承自 Map.Entry&lt;K,V&gt;</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Node</span>&lt;K,V&gt; <span class="keyword">implements</span> <span class="title class_">Map</span>.Entry&lt;K,V&gt; &#123;</span><br><span class="line">       <span class="keyword">final</span> <span class="type">int</span> hash;<span class="comment">// 哈希值，存放元素到hashmap中时用来与其他元素hash值比较</span></span><br><span class="line">       <span class="keyword">final</span> K key;<span class="comment">//键</span></span><br><span class="line">       V value;<span class="comment">//值</span></span><br><span class="line">       <span class="comment">// 指向下一个节点</span></span><br><span class="line">       Node&lt;K,V&gt; next;</span><br><span class="line">       Node(<span class="type">int</span> hash, K key, V value, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">            <span class="built_in">this</span>.hash = hash;</span><br><span class="line">            <span class="built_in">this</span>.key = key;</span><br><span class="line">            <span class="built_in">this</span>.value = value;</span><br><span class="line">            <span class="built_in">this</span>.next = next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">final</span> K <span class="title function_">getKey</span><span class="params">()</span>        &#123; <span class="keyword">return</span> key; &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">final</span> V <span class="title function_">getValue</span><span class="params">()</span>      &#123; <span class="keyword">return</span> value; &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">final</span> String <span class="title function_">toString</span><span class="params">()</span> &#123; <span class="keyword">return</span> key + <span class="string">&quot;=&quot;</span> + value; &#125;</span><br><span class="line">        <span class="comment">// 重写hashCode()方法</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> Objects.hashCode(key) ^ Objects.hashCode(value);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">final</span> V <span class="title function_">setValue</span><span class="params">(V newValue)</span> &#123;</span><br><span class="line">            <span class="type">V</span> <span class="variable">oldValue</span> <span class="operator">=</span> value;</span><br><span class="line">            value = newValue;</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 重写 equals() 方法</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (o == <span class="built_in">this</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (o <span class="keyword">instanceof</span> Map.Entry) &#123;</span><br><span class="line">                Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;)o;</span><br><span class="line">                <span class="keyword">if</span> (Objects.equals(key, e.getKey()) &amp;&amp;</span><br><span class="line">                    Objects.equals(value, e.getValue()))</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>红黑树节点类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">TreeNode</span>&lt;K,V&gt; <span class="keyword">extends</span> <span class="title class_">LinkedHashMap</span>.Entry&lt;K,V&gt; &#123;</span><br><span class="line">        TreeNode&lt;K,V&gt; parent;  <span class="comment">// 父</span></span><br><span class="line">        TreeNode&lt;K,V&gt; left;    <span class="comment">// 左</span></span><br><span class="line">        TreeNode&lt;K,V&gt; right;   <span class="comment">// 右</span></span><br><span class="line">        TreeNode&lt;K,V&gt; prev;    <span class="comment">// needed to unlink next upon deletion</span></span><br><span class="line">        <span class="type">boolean</span> red;           <span class="comment">// 判断颜色</span></span><br><span class="line">        TreeNode(<span class="type">int</span> hash, K key, V val, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">            <span class="built_in">super</span>(hash, key, val, next);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 返回根节点</span></span><br><span class="line">        <span class="keyword">final</span> TreeNode&lt;K,V&gt; <span class="title function_">root</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (TreeNode&lt;K,V&gt; r = <span class="built_in">this</span>, p;;) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((p = r.parent) == <span class="literal">null</span>)</span><br><span class="line">                    <span class="keyword">return</span> r;</span><br><span class="line">                r = p;</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure><p>HashMap构造方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 默认构造函数。</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">HashMap</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.loadFactor = DEFAULT_LOAD_FACTOR; <span class="comment">// all   other fields defaulted</span></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 包含另一个“Map”的构造函数</span></span><br><span class="line"> <span class="keyword">public</span> <span class="title function_">HashMap</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m)</span> &#123;</span><br><span class="line">     <span class="built_in">this</span>.loadFactor = DEFAULT_LOAD_FACTOR;</span><br><span class="line">     putMapEntries(m, <span class="literal">false</span>);<span class="comment">//下面会分析到这个方法</span></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 指定“容量大小”的构造函数</span></span><br><span class="line"> <span class="keyword">public</span> <span class="title function_">HashMap</span><span class="params">(<span class="type">int</span> initialCapacity)</span> &#123;</span><br><span class="line">     <span class="built_in">this</span>(initialCapacity, DEFAULT_LOAD_FACTOR);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 指定“容量大小”和“负载因子”的构造函数</span></span><br><span class="line"> <span class="keyword">public</span> <span class="title function_">HashMap</span><span class="params">(<span class="type">int</span> initialCapacity, <span class="type">float</span> loadFactor)</span> &#123;</span><br><span class="line">     <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Illegal initial capacity: &quot;</span> + initialCapacity);</span><br><span class="line">     <span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">         initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line">     <span class="keyword">if</span> (loadFactor &lt;= <span class="number">0</span> || Float.isNaN(loadFactor))</span><br><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Illegal load factor: &quot;</span> + loadFactor);</span><br><span class="line">     <span class="built_in">this</span>.loadFactor = loadFactor;</span><br><span class="line">     <span class="comment">// 初始容量暂时存放到 threshold ，在resize中再赋值给 newCap 进行table初始化</span></span><br><span class="line">     <span class="built_in">this</span>.threshold = tableSizeFor(initialCapacity);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>putMapEntries</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">putMapEntries</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m, <span class="type">boolean</span> evict)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">s</span> <span class="operator">=</span> m.size();</span><br><span class="line">    <span class="keyword">if</span> (s &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 判断table是否已经初始化</span></span><br><span class="line">        <span class="keyword">if</span> (table == <span class="literal">null</span>) &#123; <span class="comment">// pre-size</span></span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * 未初始化，s为m的实际元素个数，ft=s/loadFactor =&gt; s=ft*loadFactor, 跟我们前面提到的</span></span><br><span class="line"><span class="comment">             * 阈值=容量*负载因子 是不是很像，是的，ft指的是要添加s个元素所需的最小的容量</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="type">float</span> <span class="variable">ft</span> <span class="operator">=</span> ((<span class="type">float</span>)s / loadFactor) + <span class="number">1.0F</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">t</span> <span class="operator">=</span> ((ft &lt; (<span class="type">float</span>)MAXIMUM_CAPACITY) ?</span><br><span class="line">                    (<span class="type">int</span>)ft : MAXIMUM_CAPACITY);</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * 根据构造函数可知，table未初始化，threshold实际上是存放的初始化容量，如果添加s个元素所</span></span><br><span class="line"><span class="comment">             * 需的最小容量大于初始化容量，则将最小容量扩容为最接近的2的幂次方大小作为初始化。</span></span><br><span class="line"><span class="comment">             * 注意这里不是初始化阈值</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">if</span> (t &gt; threshold)</span><br><span class="line">                threshold = tableSizeFor(t);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 已初始化，并且m元素个数大于阈值，进行扩容处理</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (s &gt; threshold)</span><br><span class="line">            resize();</span><br><span class="line">        <span class="comment">// 将m中的所有元素添加至HashMap中，如果table未初始化，putVal中会调用resize初始化或扩容</span></span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;? <span class="keyword">extends</span> <span class="title class_">K</span>, ? <span class="keyword">extends</span> <span class="title class_">V</span>&gt; e : m.entrySet()) &#123;</span><br><span class="line">            <span class="type">K</span> <span class="variable">key</span> <span class="operator">=</span> e.getKey();</span><br><span class="line">            <span class="type">V</span> <span class="variable">value</span> <span class="operator">=</span> e.getValue();</span><br><span class="line">            putVal(hash(key), key, value, <span class="literal">false</span>, evict);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>put方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> V <span class="title function_">put</span><span class="params">(K key, V value)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> putVal(hash(key), key, value, <span class="literal">false</span>, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> V <span class="title function_">putVal</span><span class="params">(<span class="type">int</span> hash, K key, V value, <span class="type">boolean</span> onlyIfAbsent,</span></span><br><span class="line"><span class="params">                   <span class="type">boolean</span> evict)</span> &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="type">int</span> n, i;</span><br><span class="line">    <span class="comment">// table未初始化或者长度为0，进行扩容</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) == <span class="literal">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">        n = (tab = resize()).length;</span><br><span class="line">    <span class="comment">// (n - 1) &amp; hash 确定元素存放在哪个桶中，桶为空，新生成结点放入桶中(此时，这个结点是放在数组中)</span></span><br><span class="line">    <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="literal">null</span>)</span><br><span class="line">        tab[i] = newNode(hash, key, value, <span class="literal">null</span>);</span><br><span class="line">    <span class="comment">// 桶中已经存在元素（处理hash冲突）</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        Node&lt;K,V&gt; e; K k;</span><br><span class="line">        <span class="comment">//快速判断第一个节点table[i]的key是否与插入的key一样，若相同就直接使用插入的值p替换掉旧的值e。</span></span><br><span class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">            ((k = p.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                e = p;</span><br><span class="line">        <span class="comment">// 判断插入的是否是红黑树节点</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">            <span class="comment">// 放入树中</span></span><br><span class="line">            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="built_in">this</span>, tab, hash, key, value);</span><br><span class="line">        <span class="comment">// 不是红黑树节点则说明为链表结点</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 在链表最末插入结点</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">binCount</span> <span class="operator">=</span> <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                <span class="comment">// 到达链表的尾部</span></span><br><span class="line">                <span class="keyword">if</span> ((e = p.next) == <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// 在尾部插入新结点</span></span><br><span class="line">                    p.next = newNode(hash, key, value, <span class="literal">null</span>);</span><br><span class="line">                    <span class="comment">// 结点数量达到阈值(默认为 8 )，执行 treeifyBin 方法</span></span><br><span class="line">                    <span class="comment">// 这个方法会根据 HashMap 数组来决定是否转换为红黑树。</span></span><br><span class="line">                    <span class="comment">// 只有当数组长度大于或者等于 64 的情况下，才会执行转换红黑树操作，以减少搜索时间。否则，就是只是对数组扩容。</span></span><br><span class="line">                    <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">                        treeifyBin(tab, hash);</span><br><span class="line">                    <span class="comment">// 跳出循环</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 判断链表中结点的key值与插入的元素的key值是否相等</span></span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="comment">// 相等，跳出循环</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="comment">// 用于遍历桶中的链表，与前面的e = p.next组合，可以遍历链表</span></span><br><span class="line">                p = e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 表示在桶中找到key值、hash值与插入元素相等的结点</span></span><br><span class="line">        <span class="keyword">if</span> (e != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 记录e的value</span></span><br><span class="line">            <span class="type">V</span> <span class="variable">oldValue</span> <span class="operator">=</span> e.value;</span><br><span class="line">            <span class="comment">// onlyIfAbsent为false或者旧值为null</span></span><br><span class="line">            <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="literal">null</span>)</span><br><span class="line">                <span class="comment">//用新值替换旧值</span></span><br><span class="line">                e.value = value;</span><br><span class="line">            <span class="comment">// 访问后回调</span></span><br><span class="line">            afterNodeAccess(e);</span><br><span class="line">            <span class="comment">// 返回旧值</span></span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 结构性修改</span></span><br><span class="line">    ++modCount;</span><br><span class="line">    <span class="comment">// 实际大小大于阈值则扩容</span></span><br><span class="line">    <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">        resize();</span><br><span class="line">    <span class="comment">// 插入后回调</span></span><br><span class="line">    afterNodeInsertion(evict);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>get方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> V <span class="title function_">get</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="keyword">return</span> (e = getNode(hash(key), key)) == <span class="literal">null</span> ? <span class="literal">null</span> : e.value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title function_">getNode</span><span class="params">(<span class="type">int</span> hash, Object key)</span> &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; <span class="type">int</span> n; K k;</span><br><span class="line">    <span class="keyword">if</span> ((tab = table) != <span class="literal">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">        (first = tab[(n - <span class="number">1</span>) &amp; hash]) != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 数组元素相等</span></span><br><span class="line">        <span class="keyword">if</span> (first.hash == hash &amp;&amp; <span class="comment">// always check first node</span></span><br><span class="line">            ((k = first.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            <span class="keyword">return</span> first;</span><br><span class="line">        <span class="comment">// 桶中不止一个节点</span></span><br><span class="line">        <span class="keyword">if</span> ((e = first.next) != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 在树中get</span></span><br><span class="line">            <span class="keyword">if</span> (first <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                <span class="keyword">return</span> ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);</span><br><span class="line">            <span class="comment">// 在链表中get</span></span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="keyword">return</span> e;</span><br><span class="line">            &#125; <span class="keyword">while</span> ((e = e.next) != <span class="literal">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>扩容 resize方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] oldTab = table;</span><br><span class="line">    <span class="type">int</span> <span class="variable">oldCap</span> <span class="operator">=</span> (oldTab == <span class="literal">null</span>) ? <span class="number">0</span> : oldTab.length;</span><br><span class="line">    <span class="type">int</span> <span class="variable">oldThr</span> <span class="operator">=</span> threshold;</span><br><span class="line">    <span class="type">int</span> newCap, newThr = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 超过最大值就不再扩充了，就只好随你碰撞去吧</span></span><br><span class="line">        <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class="line">            threshold = Integer.MAX_VALUE;</span><br><span class="line">            <span class="keyword">return</span> oldTab;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 没超过最大值，就扩充为原来的2倍</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp; oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">            newThr = oldThr &lt;&lt; <span class="number">1</span>; <span class="comment">// double threshold</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>) <span class="comment">// initial capacity was placed in threshold</span></span><br><span class="line">        <span class="comment">// 创建对象时初始化容量大小放在threshold中，此时只需要将其作为新的数组容量</span></span><br><span class="line">        newCap = oldThr;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// signifies using defaults 无参构造函数创建的对象在这里计算容量和阈值</span></span><br><span class="line">        newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">        newThr = (<span class="type">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (newThr == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 创建时指定了初始化容量或者负载因子，在这里进行阈值初始化，</span></span><br><span class="line">    <span class="comment">// 或者扩容前的旧容量小于16，在这里计算新的resize上限</span></span><br><span class="line">        <span class="type">float</span> <span class="variable">ft</span> <span class="operator">=</span> (<span class="type">float</span>)newCap * loadFactor;</span><br><span class="line">        newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="type">float</span>)MAXIMUM_CAPACITY ? (<span class="type">int</span>)ft : Integer.MAX_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line">    threshold = newThr;</span><br><span class="line">    <span class="meta">@SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;)</span></span><br><span class="line">        Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> <span class="title class_">Node</span>[newCap];</span><br><span class="line">    table = newTab;</span><br><span class="line">    <span class="keyword">if</span> (oldTab != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 把每个bucket都移动到新的buckets中</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; oldCap; ++j) &#123;</span><br><span class="line">            Node&lt;K,V&gt; e;</span><br><span class="line">            <span class="keyword">if</span> ((e = oldTab[j]) != <span class="literal">null</span>) &#123;</span><br><span class="line">                oldTab[j] = <span class="literal">null</span>;</span><br><span class="line">                <span class="keyword">if</span> (e.next == <span class="literal">null</span>)</span><br><span class="line">                    <span class="comment">// 只有一个节点，直接计算元素新的位置即可</span></span><br><span class="line">                    newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                    <span class="comment">// 将红黑树拆分成2棵子树，如果子树节点数小于等于 UNTREEIFY_THRESHOLD（默认为 6），则将子树转换为链表。</span></span><br><span class="line">                    <span class="comment">// 如果子树节点数大于 UNTREEIFY_THRESHOLD，则保持子树的树结构。</span></span><br><span class="line">                    ((TreeNode&lt;K,V&gt;)e).split(<span class="built_in">this</span>, newTab, j, oldCap);</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    Node&lt;K,V&gt; loHead = <span class="literal">null</span>, loTail = <span class="literal">null</span>;</span><br><span class="line">                    Node&lt;K,V&gt; hiHead = <span class="literal">null</span>, hiTail = <span class="literal">null</span>;</span><br><span class="line">                    Node&lt;K,V&gt; next;</span><br><span class="line">                    <span class="keyword">do</span> &#123;</span><br><span class="line">                        next = e.next;</span><br><span class="line">                        <span class="comment">// 原索引</span></span><br><span class="line">                        <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;</span><br><span class="line">                            <span class="keyword">if</span> (loTail == <span class="literal">null</span>)</span><br><span class="line">                                loHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                loTail.next = e;</span><br><span class="line">                            loTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">// 原索引+oldCap</span></span><br><span class="line">                        <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="keyword">if</span> (hiTail == <span class="literal">null</span>)</span><br><span class="line">                                hiHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                hiTail.next = e;</span><br><span class="line">                            hiTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">while</span> ((e = next) != <span class="literal">null</span>);</span><br><span class="line">                    <span class="comment">// 原索引放到bucket里</span></span><br><span class="line">                    <span class="keyword">if</span> (loTail != <span class="literal">null</span>) &#123;</span><br><span class="line">                        loTail.next = <span class="literal">null</span>;</span><br><span class="line">                        newTab[j] = loHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 原索引+oldCap放到bucket里</span></span><br><span class="line">                    <span class="keyword">if</span> (hiTail != <span class="literal">null</span>) &#123;</span><br><span class="line">                        hiTail.next = <span class="literal">null</span>;</span><br><span class="line">                        newTab[j + oldCap] = hiHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newTab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>【Java集合】LinkedList源码</title>
      <link href="/2023/10/27/%E3%80%90Java%E9%9B%86%E5%90%88%E3%80%91LinkedList%E6%BA%90%E7%A0%81/"/>
      <url>/2023/10/27/%E3%80%90Java%E9%9B%86%E5%90%88%E3%80%91LinkedList%E6%BA%90%E7%A0%81/</url>
      
        <content type="html"><![CDATA[<p>LinkedList中Node节点定义如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Node</span>&lt;E&gt; &#123;</span><br><span class="line">    E item;<span class="comment">// 节点值</span></span><br><span class="line">    Node&lt;E&gt; next; <span class="comment">// 指向的下一个节点（后继节点）</span></span><br><span class="line">    Node&lt;E&gt; prev; <span class="comment">// 指向的前一个节点（前驱结点）</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化参数顺序分别是：前驱结点、本身节点值、后继节点</span></span><br><span class="line">    Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123;</span><br><span class="line">        <span class="built_in">this</span>.item = element;</span><br><span class="line">        <span class="built_in">this</span>.next = next;</span><br><span class="line">        <span class="built_in">this</span>.prev = prev;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>构造函数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个空的链表对象</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">LinkedList</span><span class="params">()</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 接收一个集合类型作为参数，会创建一个与传入集合相同元素的链表对象</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">LinkedList</span><span class="params">(Collection&lt;? extends E&gt; c)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>();</span><br><span class="line">    addAll(c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>插入元素</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在链表尾部插入元素</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;</span><br><span class="line">    linkLast(e);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在链表指定位置插入元素</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> index, E element)</span> &#123;</span><br><span class="line">    <span class="comment">// 下标越界检查</span></span><br><span class="line">    checkPositionIndex(index);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断 index 是不是链表尾部位置</span></span><br><span class="line">    <span class="keyword">if</span> (index == size)</span><br><span class="line">        <span class="comment">// 如果是就直接调用 linkLast 方法将元素节点插入链表尾部即可</span></span><br><span class="line">        linkLast(element);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="comment">// 如果不是则调用 linkBefore 方法将其插入指定元素之前</span></span><br><span class="line">        linkBefore(element, node(index));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将元素节点插入到链表尾部</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">linkLast</span><span class="params">(E e)</span> &#123;</span><br><span class="line">    <span class="comment">// 将最后一个元素赋值（引用传递）给节点 l</span></span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; l = last;</span><br><span class="line">    <span class="comment">// 创建节点，并指定节点前驱为链表尾节点 last，后继引用为空</span></span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; newNode = <span class="keyword">new</span> <span class="title class_">Node</span>&lt;&gt;(l, e, <span class="literal">null</span>);</span><br><span class="line">    <span class="comment">// 将 last 引用指向新节点</span></span><br><span class="line">    last = newNode;</span><br><span class="line">    <span class="comment">// 判断尾节点是否为空</span></span><br><span class="line">    <span class="comment">// 如果 l 是null 意味着这是第一次添加元素</span></span><br><span class="line">    <span class="keyword">if</span> (l == <span class="literal">null</span>)</span><br><span class="line">        <span class="comment">// 如果是第一次添加，将first赋值为新节点，此时链表只有一个元素</span></span><br><span class="line">        first = newNode;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="comment">// 如果不是第一次添加，将新节点赋值给l（添加前的最后一个元素）的next</span></span><br><span class="line">        l.next = newNode;</span><br><span class="line">    size++;</span><br><span class="line">    modCount++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在指定元素之前插入元素</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">linkBefore</span><span class="params">(E e, Node&lt;E&gt; succ)</span> &#123;</span><br><span class="line">    <span class="comment">// assert succ != null;断言 succ不为 null</span></span><br><span class="line">    <span class="comment">// 定义一个节点元素保存 succ 的 prev 引用，也就是它的前一节点信息</span></span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; pred = succ.prev;</span><br><span class="line">    <span class="comment">// 初始化节点，并指明前驱和后继节点</span></span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; newNode = <span class="keyword">new</span> <span class="title class_">Node</span>&lt;&gt;(pred, e, succ);</span><br><span class="line">    <span class="comment">// 将 succ 节点前驱引用 prev 指向新节点</span></span><br><span class="line">    succ.prev = newNode;</span><br><span class="line">    <span class="comment">// 判断尾节点是否为空，为空表示当前链表还没有节点</span></span><br><span class="line">    <span class="keyword">if</span> (pred == <span class="literal">null</span>)</span><br><span class="line">        first = newNode;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="comment">// succ 节点前驱的后继引用指向新节点</span></span><br><span class="line">        pred.next = newNode;</span><br><span class="line">    size++;</span><br><span class="line">    modCount++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>获取元素</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取链表的第一个元素</span></span><br><span class="line"><span class="keyword">public</span> E <span class="title function_">getFirst</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; f = first;</span><br><span class="line">    <span class="keyword">if</span> (f == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NoSuchElementException</span>();</span><br><span class="line">    <span class="keyword">return</span> f.item;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取链表的最后一个元素</span></span><br><span class="line"><span class="keyword">public</span> E <span class="title function_">getLast</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; l = last;</span><br><span class="line">    <span class="keyword">if</span> (l == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NoSuchElementException</span>();</span><br><span class="line">    <span class="keyword">return</span> l.item;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取链表指定位置的元素</span></span><br><span class="line"><span class="keyword">public</span> E <span class="title function_">get</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">  <span class="comment">// 下标越界检查，如果越界就抛异常</span></span><br><span class="line">  checkElementIndex(index);</span><br><span class="line">  <span class="comment">// 返回链表中对应下标的元素</span></span><br><span class="line">  <span class="keyword">return</span> node(index).item;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中<code>node(int index)</code>方法是核心</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回指定下标的非空节点</span></span><br><span class="line">Node&lt;E&gt; <span class="title function_">node</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">    <span class="comment">// 断言下标未越界</span></span><br><span class="line">    <span class="comment">// assert isElementIndex(index);</span></span><br><span class="line">    <span class="comment">// 如果index小于size的二分之一  从前开始查找（向后查找）  反之向前查找</span></span><br><span class="line">    <span class="keyword">if</span> (index &lt; (size &gt;&gt; <span class="number">1</span>)) &#123;</span><br><span class="line">        Node&lt;E&gt; x = first;</span><br><span class="line">        <span class="comment">// 遍历，循环向后查找，直至 i == index</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; index; i++)</span><br><span class="line">            x = x.next;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        Node&lt;E&gt; x = last;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> size - <span class="number">1</span>; i &gt; index; i--)</span><br><span class="line">            x = x.prev;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>删除元素</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 删除并返回链表的第一个元素</span></span><br><span class="line"><span class="keyword">public</span> E <span class="title function_">removeFirst</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; f = first;</span><br><span class="line">    <span class="keyword">if</span> (f == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NoSuchElementException</span>();</span><br><span class="line">    <span class="keyword">return</span> unlinkFirst(f);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除并返回链表的最后一个元素</span></span><br><span class="line"><span class="keyword">public</span> E <span class="title function_">removeLast</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; l = last;</span><br><span class="line">    <span class="keyword">if</span> (l == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NoSuchElementException</span>();</span><br><span class="line">    <span class="keyword">return</span> unlinkLast(l);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除链表中首次出现的指定元素，如果不存在该元素则返回 false</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">remove</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">    <span class="comment">// 如果指定元素为 null，遍历链表找到第一个为 null 的元素进行删除</span></span><br><span class="line">    <span class="keyword">if</span> (o == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (Node&lt;E&gt; x = first; x != <span class="literal">null</span>; x = x.next) &#123;</span><br><span class="line">            <span class="keyword">if</span> (x.item == <span class="literal">null</span>) &#123;</span><br><span class="line">                unlink(x);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 如果不为 null ,遍历链表找到要删除的节点</span></span><br><span class="line">        <span class="keyword">for</span> (Node&lt;E&gt; x = first; x != <span class="literal">null</span>; x = x.next) &#123;</span><br><span class="line">            <span class="keyword">if</span> (o.equals(x.item)) &#123;</span><br><span class="line">                unlink(x);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除链表指定位置的元素</span></span><br><span class="line"><span class="keyword">public</span> E <span class="title function_">remove</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">    <span class="comment">// 下标越界检查，如果越界就抛异常</span></span><br><span class="line">    checkElementIndex(index);</span><br><span class="line">    <span class="keyword">return</span> unlink(node(index));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>删除元素的核心在于<code>unlink(Node&lt;E&gt; x)</code>方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">E <span class="title function_">unlink</span><span class="params">(Node&lt;E&gt; x)</span> &#123;</span><br><span class="line">    <span class="comment">// 断言 x 不为 null</span></span><br><span class="line">    <span class="comment">// assert x != null;</span></span><br><span class="line">    <span class="comment">// 获取当前节点（也就是待删除节点）的元素</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">E</span> <span class="variable">element</span> <span class="operator">=</span> x.item;</span><br><span class="line">    <span class="comment">// 获取当前节点的下一个节点</span></span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; next = x.next;</span><br><span class="line">    <span class="comment">// 获取当前节点的前一个节点</span></span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; prev = x.prev;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果前一个节点为空，则说明当前节点是头节点</span></span><br><span class="line">    <span class="keyword">if</span> (prev == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 直接让链表头指向当前节点的下一个节点</span></span><br><span class="line">        first = next;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">// 如果前一个节点不为空</span></span><br><span class="line">        <span class="comment">// 将前一个节点的 next 指针指向当前节点的下一个节点</span></span><br><span class="line">        prev.next = next;</span><br><span class="line">        <span class="comment">// 将当前节点的 prev 指针置为 null，，方便 GC 回收</span></span><br><span class="line">        x.prev = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果下一个节点为空，则说明当前节点是尾节点</span></span><br><span class="line">    <span class="keyword">if</span> (next == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 直接让链表尾指向当前节点的前一个节点</span></span><br><span class="line">        last = prev;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">// 如果下一个节点不为空</span></span><br><span class="line">        <span class="comment">// 将下一个节点的 prev 指针指向当前节点的前一个节点</span></span><br><span class="line">        next.prev = prev;</span><br><span class="line">        <span class="comment">// 将当前节点的 next 指针置为 null，方便 GC 回收</span></span><br><span class="line">        x.next = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将当前节点元素置为 null，方便 GC 回收</span></span><br><span class="line">    x.item = <span class="literal">null</span>;</span><br><span class="line">    size--;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="keyword">return</span> element;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>【Java集合】ArrayList源码</title>
      <link href="/2023/10/27/%E3%80%90Java%E9%9B%86%E5%90%88%E3%80%91ArrayList%E6%BA%90%E7%A0%81/"/>
      <url>/2023/10/27/%E3%80%90Java%E9%9B%86%E5%90%88%E3%80%91ArrayList%E6%BA%90%E7%A0%81/</url>
      
        <content type="html"><![CDATA[<p>源码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrayList</span>&lt;E&gt; <span class="keyword">extends</span> <span class="title class_">AbstractList</span>&lt;E&gt;</span><br><span class="line">        <span class="keyword">implements</span> <span class="title class_">List</span>&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">8683452581122892189L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 默认初始容量大小</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">DEFAULT_CAPACITY</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 空数组（用于空实例）。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//用于默认大小空实例的共享空数组实例。</span></span><br><span class="line">    <span class="comment">//我们把它从EMPTY_ELEMENTDATA数组中区分出来，以知道在添加第一个元素时容量需要增加多少。</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 保存ArrayList数据的数组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">transient</span> Object[] elementData; <span class="comment">// non-private to simplify nested class access</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * ArrayList 所包含的元素个数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> size;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 带初始容量参数的构造函数（用户可以在创建ArrayList对象时自己指定集合的初始大小）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ArrayList</span><span class="params">(<span class="type">int</span> initialCapacity)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (initialCapacity &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//如果传入的参数大于0，创建initialCapacity大小的数组</span></span><br><span class="line">            <span class="built_in">this</span>.elementData = <span class="keyword">new</span> <span class="title class_">Object</span>[initialCapacity];</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (initialCapacity == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//如果传入的参数等于0，创建空数组</span></span><br><span class="line">            <span class="built_in">this</span>.elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//其他情况，抛出异常</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Illegal Capacity: &quot;</span> +</span><br><span class="line">                    initialCapacity);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 默认无参构造函数</span></span><br><span class="line"><span class="comment">     * DEFAULTCAPACITY_EMPTY_ELEMENTDATA 为0.初始化为10，也就是说初始其实是空数组 当添加第一个元素的时候数组容量才变成10</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ArrayList</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构造一个包含指定集合的元素的列表，按照它们由集合的迭代器返回的顺序。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ArrayList</span><span class="params">(Collection&lt;? extends E&gt; c)</span> &#123;</span><br><span class="line">        <span class="comment">//将指定集合转换为数组</span></span><br><span class="line">        elementData = c.toArray();</span><br><span class="line">        <span class="comment">//如果elementData数组的长度不为0</span></span><br><span class="line">        <span class="keyword">if</span> ((size = elementData.length) != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果elementData不是Object类型数据（c.toArray可能返回的不是Object类型的数组所以加上下面的语句用于判断）</span></span><br><span class="line">            <span class="keyword">if</span> (elementData.getClass() != Object[].class)</span><br><span class="line">                <span class="comment">//将原来不是Object类型的elementData数组的内容，赋值给新的Object类型的elementData数组</span></span><br><span class="line">                elementData = Arrays.copyOf(elementData, size, Object[].class);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 其他情况，用空数组代替</span></span><br><span class="line">            <span class="built_in">this</span>.elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 修改这个ArrayList实例的容量是列表的当前大小。 应用程序可以使用此操作来最小化ArrayList实例的存储。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">trimToSize</span><span class="params">()</span> &#123;</span><br><span class="line">        modCount++;</span><br><span class="line">        <span class="keyword">if</span> (size &lt; elementData.length) &#123;</span><br><span class="line">            elementData = (size == <span class="number">0</span>)</span><br><span class="line">                    ? EMPTY_ELEMENTDATA</span><br><span class="line">                    : Arrays.copyOf(elementData, size);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//下面是ArrayList的扩容机制</span></span><br><span class="line"><span class="comment">//ArrayList的扩容机制提高了性能，如果每次只扩充一个，</span></span><br><span class="line"><span class="comment">//那么频繁的插入会导致频繁的拷贝，降低性能，而ArrayList的扩容机制避免了这种情况。</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 如有必要，增加此ArrayList实例的容量，以确保它至少能容纳元素的数量</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> minCapacity 所需的最小容量</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">ensureCapacity</span><span class="params">(<span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">        <span class="comment">//如果是true，minExpand的值为0，如果是false,minExpand的值为10</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">minExpand</span> <span class="operator">=</span> (elementData != DEFAULTCAPACITY_EMPTY_ELEMENTDATA)</span><br><span class="line">                <span class="comment">// any size if not default element table</span></span><br><span class="line">                ? <span class="number">0</span></span><br><span class="line">                <span class="comment">// larger than default for default empty table. It&#x27;s already</span></span><br><span class="line">                <span class="comment">// supposed to be at default size.</span></span><br><span class="line">                : DEFAULT_CAPACITY;</span><br><span class="line">        <span class="comment">//如果最小容量大于已有的最大容量</span></span><br><span class="line">        <span class="keyword">if</span> (minCapacity &gt; minExpand) &#123;</span><br><span class="line">            ensureExplicitCapacity(minCapacity);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据给定的最小容量和当前数组元素来计算所需容量。</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">calculateCapacity</span><span class="params">(Object[] elementData, <span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">        <span class="comment">// 如果当前数组元素为空数组（初始情况），返回默认容量和最小容量中的较大值作为所需容量</span></span><br><span class="line">        <span class="keyword">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;</span><br><span class="line">            <span class="keyword">return</span> Math.max(DEFAULT_CAPACITY, minCapacity);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 否则直接返回最小容量</span></span><br><span class="line">        <span class="keyword">return</span> minCapacity;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 确保内部容量达到指定的最小容量。</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">ensureCapacityInternal</span><span class="params">(<span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">        ensureExplicitCapacity(calculateCapacity(elementData, minCapacity));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断是否需要扩容</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">ensureExplicitCapacity</span><span class="params">(<span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">        modCount++;</span><br><span class="line">        <span class="comment">// overflow-conscious code</span></span><br><span class="line">        <span class="keyword">if</span> (minCapacity - elementData.length &gt; <span class="number">0</span>)</span><br><span class="line">            <span class="comment">//调用grow方法进行扩容，调用此方法代表已经开始扩容了</span></span><br><span class="line">            grow(minCapacity);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 要分配的最大数组大小</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAX_ARRAY_SIZE</span> <span class="operator">=</span> Integer.MAX_VALUE - <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * ArrayList扩容的核心方法。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">grow</span><span class="params">(<span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">        <span class="comment">// oldCapacity为旧容量，newCapacity为新容量</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">oldCapacity</span> <span class="operator">=</span> elementData.length;</span><br><span class="line">        <span class="comment">//将oldCapacity 右移一位，其效果相当于oldCapacity /2，</span></span><br><span class="line">        <span class="comment">//我们知道位运算的速度远远快于整除运算，整句运算式的结果就是将新容量更新为旧容量的1.5倍，</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">newCapacity</span> <span class="operator">=</span> oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);</span><br><span class="line">        <span class="comment">//然后检查新容量是否大于最小需要容量，若还是小于最小需要容量，那么就把最小需要容量当作数组的新容量，</span></span><br><span class="line">        <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)</span><br><span class="line">            newCapacity = minCapacity;</span><br><span class="line">        <span class="comment">//再检查新容量是否超出了ArrayList所定义的最大容量，</span></span><br><span class="line">        <span class="comment">//若超出了，则调用hugeCapacity()来比较minCapacity和 MAX_ARRAY_SIZE，</span></span><br><span class="line">        <span class="comment">//如果minCapacity大于MAX_ARRAY_SIZE，则新容量则为Integer.MAX_VALUE，否则，新容量大小则为 MAX_ARRAY_SIZE。</span></span><br><span class="line">        <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line">            newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">        <span class="comment">// minCapacity is usually close to size, so this is a win:</span></span><br><span class="line">        elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//比较minCapacity和 MAX_ARRAY_SIZE</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">hugeCapacity</span><span class="params">(<span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (minCapacity &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">OutOfMemoryError</span>();</span><br><span class="line">        <span class="keyword">return</span> (minCapacity &gt; MAX_ARRAY_SIZE) ?</span><br><span class="line">                Integer.MAX_VALUE :</span><br><span class="line">                MAX_ARRAY_SIZE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回此列表中的元素数。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">size</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 如果此列表不包含元素，则返回 true 。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isEmpty</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//注意=和==的区别</span></span><br><span class="line">        <span class="keyword">return</span> size == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 如果此列表包含指定的元素，则返回true 。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">contains</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">        <span class="comment">//indexOf()方法：返回此列表中指定元素的首次出现的索引，如果此列表不包含此元素，则为-1</span></span><br><span class="line">        <span class="keyword">return</span> indexOf(o) &gt;= <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回此列表中指定元素的首次出现的索引，如果此列表不包含此元素，则为-1</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">indexOf</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">                <span class="keyword">if</span> (elementData[i] == <span class="literal">null</span>)</span><br><span class="line">                    <span class="keyword">return</span> i;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">                <span class="comment">//equals()方法比较</span></span><br><span class="line">                <span class="keyword">if</span> (o.equals(elementData[i]))</span><br><span class="line">                    <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回此列表中指定元素的最后一次出现的索引，如果此列表不包含元素，则返回-1。.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">lastIndexOf</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> size - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">                <span class="keyword">if</span> (elementData[i] == <span class="literal">null</span>)</span><br><span class="line">                    <span class="keyword">return</span> i;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> size - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">                <span class="keyword">if</span> (o.equals(elementData[i]))</span><br><span class="line">                    <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回此ArrayList实例的浅拷贝。 （元素本身不被复制。）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">clone</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ArrayList&lt;?&gt; v = (ArrayList&lt;?&gt;) <span class="built_in">super</span>.clone();</span><br><span class="line">            <span class="comment">//Arrays.copyOf功能是实现数组的复制，返回复制后的数组。参数是被复制的数组和复制的长度</span></span><br><span class="line">            v.elementData = Arrays.copyOf(elementData, size);</span><br><span class="line">            v.modCount = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">return</span> v;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (CloneNotSupportedException e) &#123;</span><br><span class="line">            <span class="comment">// 这不应该发生，因为我们是可以克隆的</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InternalError</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 以正确的顺序（从第一个到最后一个元素）返回一个包含此列表中所有元素的数组。</span></span><br><span class="line"><span class="comment">     * 返回的数组将是“安全的”，因为该列表不保留对它的引用。 （换句话说，这个方法必须分配一个新的数组）。</span></span><br><span class="line"><span class="comment">     * 因此，调用者可以自由地修改返回的数组。 此方法充当基于阵列和基于集合的API之间的桥梁。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Object[] toArray() &#123;</span><br><span class="line">        <span class="keyword">return</span> Arrays.copyOf(elementData, size);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 以正确的顺序返回一个包含此列表中所有元素的数组（从第一个到最后一个元素）;</span></span><br><span class="line"><span class="comment">     * 返回的数组的运行时类型是指定数组的运行时类型。 如果列表适合指定的数组，则返回其中。</span></span><br><span class="line"><span class="comment">     * 否则，将为指定数组的运行时类型和此列表的大小分配一个新数组。</span></span><br><span class="line"><span class="comment">     * 如果列表适用于指定的数组，其余空间（即数组的列表数量多于此元素），则紧跟在集合结束后的数组中的元素设置为null 。</span></span><br><span class="line"><span class="comment">     * （这仅在调用者知道列表不包含任何空元素的情况下才能确定列表的长度。）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; T[] toArray(T[] a) &#123;</span><br><span class="line">        <span class="keyword">if</span> (a.length &lt; size)</span><br><span class="line">            <span class="comment">// 新建一个运行时类型的数组，但是ArrayList数组的内容</span></span><br><span class="line">            <span class="keyword">return</span> (T[]) Arrays.copyOf(elementData, size, a.getClass());</span><br><span class="line">        <span class="comment">//调用System提供的arraycopy()方法实现数组之间的复制</span></span><br><span class="line">        System.arraycopy(elementData, <span class="number">0</span>, a, <span class="number">0</span>, size);</span><br><span class="line">        <span class="keyword">if</span> (a.length &gt; size)</span><br><span class="line">            a[size] = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Positional Access Operations</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">    E <span class="title function_">elementData</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (E) elementData[index];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回此列表中指定位置的元素。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> E <span class="title function_">get</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">        rangeCheck(index);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> elementData(index);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 用指定的元素替换此列表中指定位置的元素。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> E <span class="title function_">set</span><span class="params">(<span class="type">int</span> index, E element)</span> &#123;</span><br><span class="line">        <span class="comment">//对index进行界限检查</span></span><br><span class="line">        rangeCheck(index);</span><br><span class="line"></span><br><span class="line">        <span class="type">E</span> <span class="variable">oldValue</span> <span class="operator">=</span> elementData(index);</span><br><span class="line">        elementData[index] = element;</span><br><span class="line">        <span class="comment">//返回原来在这个位置的元素</span></span><br><span class="line">        <span class="keyword">return</span> oldValue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将指定的元素追加到此列表的末尾。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;</span><br><span class="line">        ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span></span><br><span class="line">        <span class="comment">//这里看到ArrayList添加元素的实质就相当于为数组赋值</span></span><br><span class="line">        elementData[size++] = e;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 在此列表中的指定位置插入指定的元素。</span></span><br><span class="line"><span class="comment">     * 先调用 rangeCheckForAdd 对index进行界限检查；然后调用 ensureCapacityInternal 方法保证capacity足够大；</span></span><br><span class="line"><span class="comment">     * 再将从index开始之后的所有成员后移一个位置；将element插入index位置；最后size加1。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> index, E element)</span> &#123;</span><br><span class="line">        rangeCheckForAdd(index);</span><br><span class="line"></span><br><span class="line">        ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span></span><br><span class="line">        <span class="comment">//arraycopy()这个实现数组之间复制的方法一定要看一下，下面就用到了arraycopy()方法实现数组自己复制自己</span></span><br><span class="line">        System.arraycopy(elementData, index, elementData, index + <span class="number">1</span>,</span><br><span class="line">                size - index);</span><br><span class="line">        elementData[index] = element;</span><br><span class="line">        size++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 删除该列表中指定位置的元素。 将任何后续元素移动到左侧（从其索引中减去一个元素）。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> E <span class="title function_">remove</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">        rangeCheck(index);</span><br><span class="line"></span><br><span class="line">        modCount++;</span><br><span class="line">        <span class="type">E</span> <span class="variable">oldValue</span> <span class="operator">=</span> elementData(index);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">numMoved</span> <span class="operator">=</span> size - index - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)</span><br><span class="line">            System.arraycopy(elementData, index + <span class="number">1</span>, elementData, index,</span><br><span class="line">                    numMoved);</span><br><span class="line">        elementData[--size] = <span class="literal">null</span>; <span class="comment">// clear to let GC do its work</span></span><br><span class="line">        <span class="comment">//从列表中删除的元素</span></span><br><span class="line">        <span class="keyword">return</span> oldValue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 从列表中删除指定元素的第一个出现（如果存在）。 如果列表不包含该元素，则它不会更改。</span></span><br><span class="line"><span class="comment">     * 返回true，如果此列表包含指定的元素</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">remove</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>; index &lt; size; index++)</span><br><span class="line">                <span class="keyword">if</span> (elementData[index] == <span class="literal">null</span>) &#123;</span><br><span class="line">                    fastRemove(index);</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>; index &lt; size; index++)</span><br><span class="line">                <span class="keyword">if</span> (o.equals(elementData[index])) &#123;</span><br><span class="line">                    fastRemove(index);</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Private remove method that skips bounds checking and does not</span></span><br><span class="line"><span class="comment">     * return the value removed.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">fastRemove</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">        modCount++;</span><br><span class="line">        <span class="type">int</span> <span class="variable">numMoved</span> <span class="operator">=</span> size - index - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)</span><br><span class="line">            System.arraycopy(elementData, index + <span class="number">1</span>, elementData, index,</span><br><span class="line">                    numMoved);</span><br><span class="line">        elementData[--size] = <span class="literal">null</span>; <span class="comment">// clear to let GC do its work</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 从列表中删除所有元素。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">clear</span><span class="params">()</span> &#123;</span><br><span class="line">        modCount++;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 把数组中所有的元素的值设为null</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">            elementData[i] = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        size = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 按指定集合的Iterator返回的顺序将指定集合中的所有元素追加到此列表的末尾。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">addAll</span><span class="params">(Collection&lt;? extends E&gt; c)</span> &#123;</span><br><span class="line">        Object[] a = c.toArray();</span><br><span class="line">        <span class="type">int</span> <span class="variable">numNew</span> <span class="operator">=</span> a.length;</span><br><span class="line">        ensureCapacityInternal(size + numNew);  <span class="comment">// Increments modCount</span></span><br><span class="line">        System.arraycopy(a, <span class="number">0</span>, elementData, size, numNew);</span><br><span class="line">        size += numNew;</span><br><span class="line">        <span class="keyword">return</span> numNew != <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将指定集合中的所有元素插入到此列表中，从指定的位置开始。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">addAll</span><span class="params">(<span class="type">int</span> index, Collection&lt;? extends E&gt; c)</span> &#123;</span><br><span class="line">        rangeCheckForAdd(index);</span><br><span class="line"></span><br><span class="line">        Object[] a = c.toArray();</span><br><span class="line">        <span class="type">int</span> <span class="variable">numNew</span> <span class="operator">=</span> a.length;</span><br><span class="line">        ensureCapacityInternal(size + numNew);  <span class="comment">// Increments modCount</span></span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">numMoved</span> <span class="operator">=</span> size - index;</span><br><span class="line">        <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)</span><br><span class="line">            System.arraycopy(elementData, index, elementData, index + numNew,</span><br><span class="line">                    numMoved);</span><br><span class="line"></span><br><span class="line">        System.arraycopy(a, <span class="number">0</span>, elementData, index, numNew);</span><br><span class="line">        size += numNew;</span><br><span class="line">        <span class="keyword">return</span> numNew != <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 从此列表中删除所有索引为fromIndex （含）和toIndex之间的元素。</span></span><br><span class="line"><span class="comment">     * 将任何后续元素移动到左侧（减少其索引）。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">removeRange</span><span class="params">(<span class="type">int</span> fromIndex, <span class="type">int</span> toIndex)</span> &#123;</span><br><span class="line">        modCount++;</span><br><span class="line">        <span class="type">int</span> <span class="variable">numMoved</span> <span class="operator">=</span> size - toIndex;</span><br><span class="line">        System.arraycopy(elementData, toIndex, elementData, fromIndex,</span><br><span class="line">                numMoved);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// clear to let GC do its work</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">newSize</span> <span class="operator">=</span> size - (toIndex - fromIndex);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> newSize; i &lt; size; i++) &#123;</span><br><span class="line">            elementData[i] = <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        size = newSize;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 检查给定的索引是否在范围内。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">rangeCheck</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (index &gt;= size)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IndexOutOfBoundsException</span>(outOfBoundsMsg(index));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * add和addAll使用的rangeCheck的一个版本</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">rangeCheckForAdd</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (index &gt; size || index &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IndexOutOfBoundsException</span>(outOfBoundsMsg(index));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回IndexOutOfBoundsException细节信息</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String <span class="title function_">outOfBoundsMsg</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Index: &quot;</span> + index + <span class="string">&quot;, Size: &quot;</span> + size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 从此列表中删除指定集合中包含的所有元素。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">removeAll</span><span class="params">(Collection&lt;?&gt; c)</span> &#123;</span><br><span class="line">        Objects.requireNonNull(c);</span><br><span class="line">        <span class="comment">//如果此列表被修改则返回true</span></span><br><span class="line">        <span class="keyword">return</span> batchRemove(c, <span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 仅保留此列表中包含在指定集合中的元素。</span></span><br><span class="line"><span class="comment">     * 换句话说，从此列表中删除其中不包含在指定集合中的所有元素。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">retainAll</span><span class="params">(Collection&lt;?&gt; c)</span> &#123;</span><br><span class="line">        Objects.requireNonNull(c);</span><br><span class="line">        <span class="keyword">return</span> batchRemove(c, <span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 从列表中的指定位置开始，返回列表中的元素（按正确顺序）的列表迭代器。</span></span><br><span class="line"><span class="comment">     * 指定的索引表示初始调用将返回的第一个元素为next 。 初始调用previous将返回指定索引减1的元素。</span></span><br><span class="line"><span class="comment">     * 返回的列表迭代器是fail-fast 。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> ListIterator&lt;E&gt; <span class="title function_">listIterator</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt; size)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IndexOutOfBoundsException</span>(<span class="string">&quot;Index: &quot;</span> + index);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ListItr</span>(index);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回列表中的列表迭代器（按适当的顺序）。</span></span><br><span class="line"><span class="comment">     * 返回的列表迭代器是fail-fast 。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> ListIterator&lt;E&gt; <span class="title function_">listIterator</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ListItr</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 以正确的顺序返回该列表中的元素的迭代器。</span></span><br><span class="line"><span class="comment">     * 返回的迭代器是fail-fast 。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Iterator&lt;E&gt; <span class="title function_">iterator</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Itr</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>【lc】没有卖出的卖家</title>
      <link href="/2023/10/02/%E3%80%90lc%E3%80%91%E6%B2%A1%E6%9C%89%E5%8D%96%E5%87%BA%E7%9A%84%E5%8D%96%E5%AE%B6/"/>
      <url>/2023/10/02/%E3%80%90lc%E3%80%91%E6%B2%A1%E6%9C%89%E5%8D%96%E5%87%BA%E7%9A%84%E5%8D%96%E5%AE%B6/</url>
      
        <content type="html"><![CDATA[<p>题目</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line">表: Customer</span><br><span class="line"></span><br><span class="line"><span class="operator">+</span><span class="comment">---------------+---------+</span></span><br><span class="line"><span class="operator">|</span> <span class="keyword">Column</span> Name   <span class="operator">|</span> Type    <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">---------------+---------+</span></span><br><span class="line"><span class="operator">|</span> customer_id   <span class="operator">|</span> <span class="type">int</span>     <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> customer_name <span class="operator">|</span> <span class="type">varchar</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">---------------+---------+</span></span><br><span class="line">customer_id 是该表具有唯一值的列。</span><br><span class="line">该表的每行包含网上商城的每一位顾客的信息。</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">表: Orders</span><br><span class="line"></span><br><span class="line"><span class="operator">+</span><span class="comment">---------------+---------+</span></span><br><span class="line"><span class="operator">|</span> <span class="keyword">Column</span> Name   <span class="operator">|</span> Type    <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">---------------+---------+</span></span><br><span class="line"><span class="operator">|</span> order_id      <span class="operator">|</span> <span class="type">int</span>     <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> sale_date     <span class="operator">|</span> <span class="type">date</span>    <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> order_cost    <span class="operator">|</span> <span class="type">int</span>     <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> customer_id   <span class="operator">|</span> <span class="type">int</span>     <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> seller_id     <span class="operator">|</span> <span class="type">int</span>     <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">---------------+---------+</span></span><br><span class="line">order_id 是该表具有唯一值的列。</span><br><span class="line">该表的每行包含网上商城的所有订单的信息.</span><br><span class="line">sale_date 是顾客 customer_id 和卖家 seller_id 之间交易的日期.</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">表: Seller</span><br><span class="line"></span><br><span class="line"><span class="operator">+</span><span class="comment">---------------+---------+</span></span><br><span class="line"><span class="operator">|</span> <span class="keyword">Column</span> Name   <span class="operator">|</span> Type    <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">---------------+---------+</span></span><br><span class="line"><span class="operator">|</span> seller_id     <span class="operator">|</span> <span class="type">int</span>     <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> seller_name   <span class="operator">|</span> <span class="type">varchar</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">---------------+---------+</span></span><br><span class="line">seller_id 是该表主具有唯一值的列。</span><br><span class="line">该表的每行包含每一位卖家的信息.</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">写一个解决方案, 报告所有在 <span class="number">2020</span> 年度没有任何卖出的卖家的名字。</span><br><span class="line"></span><br><span class="line">返回结果按照 seller_name 升序排列。</span><br><span class="line"></span><br><span class="line">查询结果格式如下例所示。</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">示例 <span class="number">1</span>:</span><br><span class="line"></span><br><span class="line">输入：</span><br><span class="line">Customer 表:</span><br><span class="line"><span class="operator">+</span><span class="comment">--------------+---------------+</span></span><br><span class="line"><span class="operator">|</span> customer_id  <span class="operator">|</span> customer_name <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--------------+---------------+</span></span><br><span class="line"><span class="operator">|</span> <span class="number">101</span>          <span class="operator">|</span> Alice         <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">102</span>          <span class="operator">|</span> Bob           <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">103</span>          <span class="operator">|</span> Charlie       <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--------------+---------------+</span></span><br><span class="line">Orders 表:</span><br><span class="line"><span class="operator">+</span><span class="comment">-------------+------------+--------------+-------------+-------------+</span></span><br><span class="line"><span class="operator">|</span> order_id    <span class="operator">|</span> sale_date  <span class="operator">|</span> order_cost   <span class="operator">|</span> customer_id <span class="operator">|</span> seller_id   <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------------+------------+--------------+-------------+-------------+</span></span><br><span class="line"><span class="operator">|</span> <span class="number">1</span>           <span class="operator">|</span> <span class="number">2020</span><span class="number">-03</span><span class="number">-01</span> <span class="operator">|</span> <span class="number">1500</span>         <span class="operator">|</span> <span class="number">101</span>         <span class="operator">|</span> <span class="number">1</span>           <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">2</span>           <span class="operator">|</span> <span class="number">2020</span><span class="number">-05</span><span class="number">-25</span> <span class="operator">|</span> <span class="number">2400</span>         <span class="operator">|</span> <span class="number">102</span>         <span class="operator">|</span> <span class="number">2</span>           <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">3</span>           <span class="operator">|</span> <span class="number">2019</span><span class="number">-05</span><span class="number">-25</span> <span class="operator">|</span> <span class="number">800</span>          <span class="operator">|</span> <span class="number">101</span>         <span class="operator">|</span> <span class="number">3</span>           <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">4</span>           <span class="operator">|</span> <span class="number">2020</span><span class="number">-09</span><span class="number">-13</span> <span class="operator">|</span> <span class="number">1000</span>         <span class="operator">|</span> <span class="number">103</span>         <span class="operator">|</span> <span class="number">2</span>           <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">5</span>           <span class="operator">|</span> <span class="number">2019</span><span class="number">-02</span><span class="number">-11</span> <span class="operator">|</span> <span class="number">700</span>          <span class="operator">|</span> <span class="number">101</span>         <span class="operator">|</span> <span class="number">2</span>           <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------------+------------+--------------+-------------+-------------+</span></span><br><span class="line">Seller 表:</span><br><span class="line"><span class="operator">+</span><span class="comment">-------------+-------------+</span></span><br><span class="line"><span class="operator">|</span> seller_id   <span class="operator">|</span> seller_name <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------------+-------------+</span></span><br><span class="line"><span class="operator">|</span> <span class="number">1</span>           <span class="operator">|</span> Daniel      <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">2</span>           <span class="operator">|</span> Elizabeth   <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">3</span>           <span class="operator">|</span> Frank       <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------------+-------------+</span></span><br><span class="line">输出：</span><br><span class="line"><span class="operator">+</span><span class="comment">-------------+</span></span><br><span class="line"><span class="operator">|</span> seller_name <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------------+</span></span><br><span class="line"><span class="operator">|</span> Frank       <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------------+</span></span><br><span class="line">解释：</span><br><span class="line">Daniel 在 <span class="number">2020</span> 年 <span class="number">3</span> 月卖出 <span class="number">1</span> 次。</span><br><span class="line">Elizabeth 在 <span class="number">2020</span> 年卖出 <span class="number">2</span> 次, 在 <span class="number">2019</span> 年卖出 <span class="number">1</span> 次。</span><br><span class="line">Frank 在 <span class="number">2019</span> 年卖出 <span class="number">1</span> 次, 在 <span class="number">2020</span> 年没有卖出。</span><br></pre></td></tr></table></figure><p>年份处于2020年的几种方式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">YEAR(sale_date)=2020</span><br><span class="line">sale_date &gt;= &#x27;2020-01-01&#x27; AND sale_date &lt;= &#x27;2020-12-31&#x27;</span><br><span class="line">sale_date like &#x27;2020%&#x27;</span><br><span class="line">sale_date REGEXP &#x27;^2020&#x27;</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> seller_name</span><br><span class="line"><span class="keyword">FROM</span> Seller s </span><br><span class="line"><span class="keyword">LEFT</span> <span class="keyword">JOIN</span> Orders o </span><br><span class="line"><span class="keyword">ON</span> s.seller_id <span class="operator">=</span> o.seller_id <span class="keyword">AND</span> <span class="keyword">YEAR</span>(o.sale_date) <span class="operator">=</span> <span class="number">2020</span></span><br><span class="line"><span class="keyword">WHERE</span> o.order_id <span class="keyword">IS</span> <span class="keyword">NULL</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> seller_name</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【lc】计算特殊奖金</title>
      <link href="/2023/10/02/%E3%80%90lc%E3%80%91%E8%AE%A1%E7%AE%97%E7%89%B9%E6%AE%8A%E5%A5%96%E9%87%91/"/>
      <url>/2023/10/02/%E3%80%90lc%E3%80%91%E8%AE%A1%E7%AE%97%E7%89%B9%E6%AE%8A%E5%A5%96%E9%87%91/</url>
      
        <content type="html"><![CDATA[<p>题目</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">表: Employees</span><br><span class="line"><span class="operator">+</span><span class="comment">-------------+---------+</span></span><br><span class="line"><span class="operator">|</span> 列名        <span class="operator">|</span> 类型     <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------------+---------+</span></span><br><span class="line"><span class="operator">|</span> employee_id <span class="operator">|</span> <span class="type">int</span>     <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> name        <span class="operator">|</span> <span class="type">varchar</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> salary      <span class="operator">|</span> <span class="type">int</span>     <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------------+---------+</span></span><br><span class="line">employee_id 是这个表的主键(具有唯一值的列)。</span><br><span class="line">此表的每一行给出了雇员id ，名字和薪水。</span><br><span class="line"></span><br><span class="line">编写解决方案，计算每个雇员的奖金。</span><br><span class="line">如果一个雇员的 id 是 奇数 并且他的名字不是以 <span class="string">&#x27;M&#x27;</span> 开头，</span><br><span class="line">那么他的奖金是他工资的 <span class="number">100</span><span class="operator">%</span> ，否则奖金为 <span class="number">0</span> 。</span><br><span class="line">返回的结果按照 employee_id 排序。</span><br><span class="line">返回结果格式如下面的例子所示。</span><br><span class="line"></span><br><span class="line">示例 <span class="number">1</span>:</span><br><span class="line">输入：</span><br><span class="line">Employees 表:</span><br><span class="line"><span class="operator">+</span><span class="comment">-------------+---------+--------+</span></span><br><span class="line"><span class="operator">|</span> employee_id <span class="operator">|</span> name    <span class="operator">|</span> salary <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------------+---------+--------+</span></span><br><span class="line"><span class="operator">|</span> <span class="number">2</span>           <span class="operator">|</span> Meir    <span class="operator">|</span> <span class="number">3000</span>   <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">3</span>           <span class="operator">|</span> Michael <span class="operator">|</span> <span class="number">3800</span>   <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">7</span>           <span class="operator">|</span> Addilyn <span class="operator">|</span> <span class="number">7400</span>   <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">8</span>           <span class="operator">|</span> Juan    <span class="operator">|</span> <span class="number">6100</span>   <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">9</span>           <span class="operator">|</span> Kannon  <span class="operator">|</span> <span class="number">7700</span>   <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------------+---------+--------+</span></span><br><span class="line">输出：</span><br><span class="line"><span class="operator">+</span><span class="comment">-------------+-------+</span></span><br><span class="line"><span class="operator">|</span> employee_id <span class="operator">|</span> bonus <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------------+-------+</span></span><br><span class="line"><span class="operator">|</span> <span class="number">2</span>           <span class="operator">|</span> <span class="number">0</span>     <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">3</span>           <span class="operator">|</span> <span class="number">0</span>     <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">7</span>           <span class="operator">|</span> <span class="number">7400</span>  <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">8</span>           <span class="operator">|</span> <span class="number">0</span>     <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">9</span>           <span class="operator">|</span> <span class="number">7700</span>  <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------------+-------+</span></span><br><span class="line">解释：</span><br><span class="line">因为雇员id是偶数，所以雇员id 是<span class="number">2</span>和<span class="number">8</span>的两个雇员得到的奖金是<span class="number">0</span>。</span><br><span class="line">雇员id为<span class="number">3</span>的因为他的名字以<span class="string">&#x27;M&#x27;</span>开头，所以，奖金是<span class="number">0</span>。</span><br><span class="line">其他的雇员得到了百分之百的奖金。</span><br></pre></td></tr></table></figure><p>不以<code>M</code>开头的字符串，用正则表达式</p><p><code>REGEXP</code> 是 <code>SQL</code> 中的一个关键字组合，用于<strong>匹配符合某个正则表达式</strong>规则的数据。</p><p>先找出以<code>M</code>开头的字符串，<code>REGEXP &#39;^M&#39;</code>，<code>&#39;^&#39;</code>表示字符串的开始，则<code>&#39;^M&#39;</code>表示以<code>M</code>开头的字符串。</p><p>那么，不以<code>M</code>开头的字符串可以写为<code>NOT REGEXP &#39;^M&#39;</code></p><p><code>SQL</code>的<code>IF</code>语句：</p><p><code>IF(condition, true_value, false_value)</code>，如果<code>condition</code>成立，则取左边的值，否则取右边的值</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> </span><br><span class="line">employee_id, IF(employee_id <span class="operator">%</span> <span class="number">2</span> <span class="operator">!=</span> <span class="number">1</span> <span class="keyword">AND</span> name <span class="keyword">NOT</span> REGEXP <span class="string">&#x27;^M&#x27;</span>, salary, <span class="number">0</span>) <span class="keyword">as</span> bonus</span><br><span class="line"><span class="keyword">FROM</span> Employees</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> employee_id</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【lc】从前序与中序遍历序列构造二叉树</title>
      <link href="/2023/10/02/%E3%80%90lc%E3%80%91%E4%BB%8E%E5%89%8D%E5%BA%8F%E4%B8%8E%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
      <url>/2023/10/02/%E3%80%90lc%E3%80%91%E4%BB%8E%E5%89%8D%E5%BA%8F%E4%B8%8E%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<p>题目</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">给定两个整数数组 preorder 和 inorder ，其中 preorder 是二叉树的先序遍历， inorder 是同一棵树的中序遍历，请构造二叉树并返回其根节点。</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">示例 <span class="number">1</span>:</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">输入: preorder = [<span class="number">3</span>,<span class="number">9</span>,<span class="number">20</span>,<span class="number">15</span>,<span class="number">7</span>], inorder = [<span class="number">9</span>,<span class="number">3</span>,<span class="number">15</span>,<span class="number">20</span>,<span class="number">7</span>]</span><br><span class="line">输出: [<span class="number">3</span>,<span class="number">9</span>,<span class="number">20</span>,<span class="literal">null</span>,<span class="literal">null</span>,<span class="number">15</span>,<span class="number">7</span>]</span><br><span class="line">示例 <span class="number">2</span>:</span><br><span class="line"></span><br><span class="line">输入: preorder = [-<span class="number">1</span>], inorder = [-<span class="number">1</span>]</span><br><span class="line">输出: [-<span class="number">1</span>]</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">提示:</span><br><span class="line"></span><br><span class="line"><span class="number">1</span> &lt;= preorder.length &lt;= <span class="number">3000</span></span><br><span class="line">inorder.length == preorder.length</span><br><span class="line">-<span class="number">3000</span> &lt;= preorder[i], inorder[i] &lt;= <span class="number">3000</span></span><br><span class="line">preorder 和 inorder 均 无重复 元素</span><br><span class="line">inorder 均出现在 preorder</span><br><span class="line">preorder 保证 为二叉树的前序遍历序列</span><br><span class="line">inorder 保证 为二叉树的中序遍历序列</span><br></pre></td></tr></table></figure><p>思路：</p><p>利用递归分治，前序遍历、中序遍历区间上，分别属于左子树和右子树的范围即可</p><p>代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">buildTree</span>(<span class="params">self, preorder: <span class="type">List</span>[<span class="built_in">int</span>], inorder: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">Optional</span>[TreeNode]:</span><br><span class="line">        <span class="comment"># 递归终止条件</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> preorder: <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        left_size = inorder.index(preorder[<span class="number">0</span>])</span><br><span class="line">        <span class="comment"># 划分左子树的区间</span></span><br><span class="line">        left = self.buildTree(preorder[<span class="number">1</span> : left_size + <span class="number">1</span>], inorder[:left_size])</span><br><span class="line">        <span class="comment"># 划分右子树的区间</span></span><br><span class="line">        right = self.buildTree(preorder[left_size + <span class="number">1</span>:], inorder[left_size + <span class="number">1</span>:])</span><br><span class="line">        <span class="comment"># 生成当前根节点</span></span><br><span class="line">        <span class="keyword">return</span> TreeNode(preorder[<span class="number">0</span>], left, right)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【lc】反转链表II</title>
      <link href="/2023/10/02/%E3%80%90lc%E3%80%91%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8II/"/>
      <url>/2023/10/02/%E3%80%90lc%E3%80%91%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8II/</url>
      
        <content type="html"><![CDATA[<p>题目</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">给你单链表的头指针 head 和两个整数 left 和 right ，其中 left &lt;= right 。请你反转从位置 left 到位置 right 的链表节点，返回 反转后的链表 。</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">示例 <span class="number">1</span>：</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">输入：head = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>], left = <span class="number">2</span>, right = <span class="number">4</span></span><br><span class="line">输出：[<span class="number">1</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">5</span>]</span><br><span class="line">示例 <span class="number">2</span>：</span><br><span class="line"></span><br><span class="line">输入：head = [<span class="number">5</span>], left = <span class="number">1</span>, right = <span class="number">1</span></span><br><span class="line">输出：[<span class="number">5</span>]</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line"></span><br><span class="line">链表中节点数目为 n</span><br><span class="line"><span class="number">1</span> &lt;= n &lt;= <span class="number">500</span></span><br><span class="line">-<span class="number">500</span> &lt;= Node.val &lt;= <span class="number">500</span></span><br><span class="line"><span class="number">1</span> &lt;= left &lt;= right &lt;= n</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">进阶： 你可以使用一趟扫描完成反转吗？</span><br></pre></td></tr></table></figure><p>题目大致意思就是，给定链表中任意一段，然后将这一段反转，其他部分不变。</p><p>思路1：</p><p>用最笨的方法：将后半部分隔离出来</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, next=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.next = next</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">reverseBetween</span>(<span class="params">self, head: <span class="type">Optional</span>[ListNode], left: <span class="built_in">int</span>, right: <span class="built_in">int</span></span>) -&gt; <span class="type">Optional</span>[ListNode]:</span><br><span class="line">        <span class="keyword">if</span> left == right: <span class="keyword">return</span> head</span><br><span class="line">        <span class="comment"># 先用最笨的方法，将最后面的小尾巴给保存起来</span></span><br><span class="line">        <span class="comment"># 计算链表长度</span></span><br><span class="line">        a = head</span><br><span class="line">        list_len = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> a:</span><br><span class="line">            a = a.<span class="built_in">next</span></span><br><span class="line">            list_len += <span class="number">1</span></span><br><span class="line">        a = head</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(right - <span class="number">1</span>):</span><br><span class="line">            a = a.<span class="built_in">next</span></span><br><span class="line">        <span class="comment"># 将尾巴保存起来</span></span><br><span class="line">        tail = a.<span class="built_in">next</span></span><br><span class="line">        a.<span class="built_in">next</span> = <span class="literal">None</span></span><br><span class="line">        <span class="comment"># 然后找到起始位置，开始反转</span></span><br><span class="line">        dummy = ListNode()</span><br><span class="line">        dummy.<span class="built_in">next</span> = head</span><br><span class="line">        a = dummy</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(left - <span class="number">1</span>):</span><br><span class="line">            a = a.<span class="built_in">next</span></span><br><span class="line">        cur, pre = a.<span class="built_in">next</span>, <span class="literal">None</span></span><br><span class="line">        <span class="keyword">while</span> cur:</span><br><span class="line">            tmp = cur.<span class="built_in">next</span></span><br><span class="line">            cur.<span class="built_in">next</span> = pre</span><br><span class="line">            pre = cur</span><br><span class="line">            cur = tmp</span><br><span class="line">        <span class="comment"># 反转完毕，拼接前一部分</span></span><br><span class="line">        a.<span class="built_in">next</span> = pre</span><br><span class="line">        <span class="comment"># 拼接最后一部分</span></span><br><span class="line">        <span class="keyword">while</span> a.<span class="built_in">next</span>:</span><br><span class="line">            a = a.<span class="built_in">next</span></span><br><span class="line">        a.<span class="built_in">next</span> = tail</span><br><span class="line">        <span class="keyword">return</span> dummy.<span class="built_in">next</span></span><br></pre></td></tr></table></figure><p> 此时，时间复杂度为O(n)，空间复杂度为O(1)</p><p>但是经历了多于一轮的遍历，题目中提到：<code>一趟扫描</code></p><p>那么就引出了思路2</p><p>思路2：</p><p>利用头插法，一趟扫描</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">reverseBetween</span>(<span class="params">self, head: ListNode, left: <span class="built_in">int</span>, right: <span class="built_in">int</span></span>) -&gt; ListNode:</span><br><span class="line">        <span class="comment"># 设置dummynode</span></span><br><span class="line">        dummynode = ListNode(-<span class="number">1</span>)</span><br><span class="line">        dummynode.<span class="built_in">next</span> = head</span><br><span class="line">        <span class="comment"># 找到要反转的部分的前一个节点</span></span><br><span class="line">        pre = dummynode</span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(left - <span class="number">1</span>):</span><br><span class="line">            pre = pre.<span class="built_in">next</span></span><br><span class="line">        <span class="comment"># 利用头插法进行反转</span></span><br><span class="line">        cur = pre.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(right - left):</span><br><span class="line">            <span class="built_in">next</span> = cur.<span class="built_in">next</span></span><br><span class="line">            cur.<span class="built_in">next</span> = <span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line">            <span class="built_in">next</span>.<span class="built_in">next</span> = pre.<span class="built_in">next</span></span><br><span class="line">            pre.<span class="built_in">next</span> = <span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> dummynode.<span class="built_in">next</span></span><br></pre></td></tr></table></figure><p>同样，时间复杂度为O(n)，空间复杂度为O(1)</p><p>但是会略微的比思路1要快一些。因为要遍历的轮数减少了。。。</p>]]></content>
      
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【lc】复原IP地址</title>
      <link href="/2023/10/02/%E3%80%90lc%E3%80%91%E5%A4%8D%E5%8E%9FIP%E5%9C%B0%E5%9D%80/"/>
      <url>/2023/10/02/%E3%80%90lc%E3%80%91%E5%A4%8D%E5%8E%9FIP%E5%9C%B0%E5%9D%80/</url>
      
        <content type="html"><![CDATA[<p>题目</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">有效 IP 地址 正好由四个整数（每个整数位于 <span class="number">0</span> 到 <span class="number">255</span> 之间组成，且不能含有前导 <span class="number">0</span>），整数之间用 <span class="string">&#x27;.&#x27;</span> 分隔。</span><br><span class="line"></span><br><span class="line">例如：<span class="string">&quot;0.1.2.201&quot;</span> 和 <span class="string">&quot;192.168.1.1&quot;</span> 是 有效 IP 地址，但是 <span class="string">&quot;0.011.255.245&quot;</span>、<span class="string">&quot;192.168.1.312&quot;</span> 和 <span class="string">&quot;192.168@1.1&quot;</span> 是 无效 IP 地址。</span><br><span class="line">给定一个只包含数字的字符串 s ，用以表示一个 IP 地址，返回所有可能的有效 IP 地址，这些地址可以通过在 s 中插入 <span class="string">&#x27;.&#x27;</span> 来形成。你 不能 重新排序或删除 s 中的任何数字。你可以按 任何 顺序返回答案。</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">示例 <span class="number">1</span>：</span><br><span class="line"></span><br><span class="line">输入：s = <span class="string">&quot;25525511135&quot;</span></span><br><span class="line">输出：[<span class="string">&quot;255.255.11.135&quot;</span>,<span class="string">&quot;255.255.111.35&quot;</span>]</span><br><span class="line">示例 <span class="number">2</span>：</span><br><span class="line"></span><br><span class="line">输入：s = <span class="string">&quot;0000&quot;</span></span><br><span class="line">输出：[<span class="string">&quot;0.0.0.0&quot;</span>]</span><br><span class="line">示例 <span class="number">3</span>：</span><br><span class="line"></span><br><span class="line">输入：s = <span class="string">&quot;101023&quot;</span></span><br><span class="line">输出：[<span class="string">&quot;1.0.10.23&quot;</span>,<span class="string">&quot;1.0.102.3&quot;</span>,<span class="string">&quot;10.1.0.23&quot;</span>,<span class="string">&quot;10.10.2.3&quot;</span>,<span class="string">&quot;101.0.2.3&quot;</span>]</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line"></span><br><span class="line"><span class="number">1</span> &lt;= s.length &lt;= <span class="number">20</span></span><br><span class="line">s 仅由数字组成</span><br></pre></td></tr></table></figure><p>思路：</p><p>使用回溯法</p><p>需要几个变量：</p><ol><li>答案数组res</li><li>当前是第几个ip段</li><li>当前IP的其他几个段</li></ol><p>代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">restoreIpAddresses</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">str</span>]:</span><br><span class="line">        segments = [<span class="number">0</span>] * <span class="number">4</span></span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">backtrack</span>(<span class="params">idx, start</span>):</span><br><span class="line">            <span class="comment"># 已经凑够4个ip段了</span></span><br><span class="line">            <span class="keyword">if</span> idx == <span class="number">4</span>:</span><br><span class="line">                <span class="comment"># s用完了</span></span><br><span class="line">                <span class="keyword">if</span> start == <span class="built_in">len</span>(s):</span><br><span class="line">                    address = <span class="string">&quot;.&quot;</span>.join(<span class="built_in">str</span>(seg) <span class="keyword">for</span> seg <span class="keyword">in</span> segments)</span><br><span class="line">                    res.append(address)</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="comment"># 没凑够4个就用完s了</span></span><br><span class="line">            <span class="keyword">if</span> start == <span class="built_in">len</span>(s):</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="comment"># 当前遇到了0</span></span><br><span class="line">            <span class="keyword">if</span> s[start] == <span class="string">&quot;0&quot;</span>:</span><br><span class="line">                segments[idx] = <span class="number">0</span></span><br><span class="line">                backtrack(idx + <span class="number">1</span>, start + <span class="number">1</span>)</span><br><span class="line">                </span><br><span class="line">            <span class="comment"># 正常进行</span></span><br><span class="line">            address = <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> end <span class="keyword">in</span> <span class="built_in">range</span>(start, <span class="built_in">len</span>(s)):</span><br><span class="line">                address = address * <span class="number">10</span> + <span class="built_in">ord</span>(s[end]) - <span class="built_in">ord</span>(<span class="string">&quot;0&quot;</span>)</span><br><span class="line">                <span class="keyword">if</span> <span class="number">0</span> &lt; address &lt;= <span class="number">255</span>:</span><br><span class="line">                    segments[idx] = address</span><br><span class="line">                    backtrack(idx + <span class="number">1</span>, end + <span class="number">1</span>)</span><br><span class="line">                <span class="comment"># 越界了</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">return</span></span><br><span class="line">        backtrack(<span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【lc】重排链表</title>
      <link href="/2023/10/02/%E3%80%90lc%E3%80%91%E9%87%8D%E6%8E%92%E9%93%BE%E8%A1%A8/"/>
      <url>/2023/10/02/%E3%80%90lc%E3%80%91%E9%87%8D%E6%8E%92%E9%93%BE%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<p>题目</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">给定一个单链表 L 的头节点 head ，单链表 L 表示为：</span><br><span class="line"></span><br><span class="line">L0 → L1 → … → Ln - <span class="number">1</span> → Ln</span><br><span class="line">请将其重新排列后变为：</span><br><span class="line"></span><br><span class="line">L0 → Ln → L1 → Ln - <span class="number">1</span> → L2 → Ln - <span class="number">2</span> → …</span><br><span class="line">不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。</span><br></pre></td></tr></table></figure><p><img src="https://coldwater.oss-cn-beijing.aliyuncs.com/img/20240402223549.png"></p><p>思路：</p><p>考察了三个知识点</p><ol><li>找链表中心点</li><li>逆置链表</li><li>交叉重组链表</li></ol><p>链表中心点：</p><p>利用快慢链表</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">slow = fast = head</span><br><span class="line"><span class="keyword">while</span> fast.<span class="built_in">next</span> <span class="keyword">and</span> fast.<span class="built_in">next</span>.<span class="built_in">next</span>:</span><br><span class="line">    slow = slow.<span class="built_in">next</span></span><br><span class="line">    fast = fast.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line"><span class="keyword">return</span> slow</span><br></pre></td></tr></table></figure><p>逆置链表：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">p = head</span><br><span class="line">pre = <span class="literal">None</span></span><br><span class="line"><span class="keyword">while</span> p:</span><br><span class="line">    q = p</span><br><span class="line">    p = p.<span class="built_in">next</span></span><br><span class="line">    q.<span class="built_in">next</span> = pre</span><br><span class="line">    pre = q</span><br><span class="line"><span class="keyword">return</span> pre</span><br></pre></td></tr></table></figure><p>交叉重组链表：</p><p>画个图模拟一下即可</p><p>代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, next=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.next = next</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">reorderList</span>(<span class="params">self, head: <span class="type">Optional</span>[ListNode]</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Do not return anything, modify head in-place instead.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        slow = fast = head</span><br><span class="line">        <span class="keyword">while</span> fast.<span class="built_in">next</span> <span class="keyword">and</span> fast.<span class="built_in">next</span>.<span class="built_in">next</span>:</span><br><span class="line">            slow = slow.<span class="built_in">next</span></span><br><span class="line">            fast = fast.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line">        p = slow.<span class="built_in">next</span></span><br><span class="line">        slow.<span class="built_in">next</span> = <span class="literal">None</span></span><br><span class="line">        pre = <span class="literal">None</span></span><br><span class="line">        <span class="keyword">while</span> p:</span><br><span class="line">            q = p</span><br><span class="line">            p = p.<span class="built_in">next</span></span><br><span class="line">            q.<span class="built_in">next</span> = pre</span><br><span class="line">            pre = q</span><br><span class="line">        <span class="comment"># head和pre分别指向左边和右边两个链表的起点</span></span><br><span class="line">        a, b = head, pre</span><br><span class="line">        <span class="keyword">while</span> a.<span class="built_in">next</span>:</span><br><span class="line">            nxt = b.<span class="built_in">next</span></span><br><span class="line">            b.<span class="built_in">next</span> = a.<span class="built_in">next</span></span><br><span class="line">            a.<span class="built_in">next</span> = b</span><br><span class="line">            a = b.<span class="built_in">next</span></span><br><span class="line">            b = nxt</span><br><span class="line">        a.<span class="built_in">next</span> = b</span><br><span class="line">        <span class="keyword">return</span> head</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【lc】除自身以外数组的乘积</title>
      <link href="/2023/10/01/%E3%80%90lc%E3%80%91%E9%99%A4%E8%87%AA%E8%BA%AB%E4%BB%A5%E5%A4%96%E6%95%B0%E7%BB%84%E7%9A%84%E4%B9%98%E7%A7%AF/"/>
      <url>/2023/10/01/%E3%80%90lc%E3%80%91%E9%99%A4%E8%87%AA%E8%BA%AB%E4%BB%A5%E5%A4%96%E6%95%B0%E7%BB%84%E7%9A%84%E4%B9%98%E7%A7%AF/</url>
      
        <content type="html"><![CDATA[<p>题目</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">给你一个整数数组 nums，返回 数组 answer ，其中 answer[i] 等于 nums 中除 nums[i] 之外其余各元素的乘积 。</span><br><span class="line"></span><br><span class="line">题目数据 保证 数组 nums之中任意元素的全部前缀元素和后缀的乘积都在  <span class="number">32</span> 位 整数范围内。</span><br><span class="line"></span><br><span class="line">请 不要使用除法，且在 O(n) 时间复杂度内完成此题。</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">示例 <span class="number">1</span>:</span><br><span class="line"></span><br><span class="line">输入: nums = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line">输出: [<span class="number">24</span>,<span class="number">12</span>,<span class="number">8</span>,<span class="number">6</span>]</span><br><span class="line">示例 <span class="number">2</span>:</span><br><span class="line"></span><br><span class="line">输入: nums = [-<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,-<span class="number">3</span>,<span class="number">3</span>]</span><br><span class="line">输出: [<span class="number">0</span>,<span class="number">0</span>,<span class="number">9</span>,<span class="number">0</span>,<span class="number">0</span>]</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line"></span><br><span class="line"><span class="number">2</span> &lt;= nums.length &lt;= <span class="number">105</span></span><br><span class="line">-<span class="number">30</span> &lt;= nums[i] &lt;= <span class="number">30</span></span><br><span class="line">保证 数组 nums之中任意元素的全部前缀元素和后缀的乘积都在  <span class="number">32</span> 位 整数范围内</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">进阶：你可以在 O(<span class="number">1</span>) 的额外空间复杂度内完成这个题目吗？（ 出于对空间复杂度分析的目的，输出数组 不被视为 额外空间。）</span><br></pre></td></tr></table></figure><p>思路：</p><p>参考k神的，利用上三角和下三角矩阵</p><p>因为时间复杂度是O(N)，而且不能用除法。</p><p>如何找到答案中第<code>i</code>个位置的值呢？可以想一下。</p><p><code>res[i]</code>代表什么呢？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">res[i] = a[0] * a[1] * ... * a[i-1] * a[i+1] * ... * a[n-1]</span><br></pre></td></tr></table></figure><p>那么也就是说，是<code>i</code>左边所有元素和右边所有元素的乘积。</p><p>那么在上三角矩阵和下三角矩阵中，下三角就代表着元素<code>i</code>左边的元素，上三角就代表这元素<code>i</code>右边的元素。</p><p><img src="https://coldwater.oss-cn-beijing.aliyuncs.com/img/20240402223620.png"></p><p>也就是可以通过两轮遍历（计算下三角然后计算上三角，反着来也可以）来得到答案</p><p>代码如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">productExceptSelf</span>(<span class="params">self, a: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        n = <span class="built_in">len</span>(a)</span><br><span class="line">        res = [<span class="number">1</span>] * n</span><br><span class="line">        <span class="comment"># 计算下三角</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n):</span><br><span class="line">            res[i] = res[i-<span class="number">1</span>] * a[i-<span class="number">1</span>]</span><br><span class="line">        <span class="comment"># 计算上三角</span></span><br><span class="line">        tmp = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n - <span class="number">2</span>, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">            tmp *= a[i+<span class="number">1</span>]</span><br><span class="line">            res[i] *= tmp</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【lc】寻找旋转排序数组中的最小值</title>
      <link href="/2023/10/01/%E3%80%90lc%E3%80%91%E5%AF%BB%E6%89%BE%E6%97%8B%E8%BD%AC%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9C%80%E5%B0%8F%E5%80%BC/"/>
      <url>/2023/10/01/%E3%80%90lc%E3%80%91%E5%AF%BB%E6%89%BE%E6%97%8B%E8%BD%AC%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9C%80%E5%B0%8F%E5%80%BC/</url>
      
        <content type="html"><![CDATA[<p>题目</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">已知一个长度为 n 的数组，预先按照升序排列，经由 <span class="number">1</span> 到 n 次 旋转 后，得到输入数组。例如，原数组 nums = [<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>] 在变化后可能得到：</span><br><span class="line">若旋转 <span class="number">4</span> 次，则可以得到 [<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>]</span><br><span class="line">若旋转 <span class="number">7</span> 次，则可以得到 [<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>]</span><br><span class="line">注意，数组 [a[<span class="number">0</span>], a[<span class="number">1</span>], a[<span class="number">2</span>], ..., a[n-<span class="number">1</span>]] 旋转一次 的结果为数组 [a[n-<span class="number">1</span>], a[<span class="number">0</span>], a[<span class="number">1</span>], a[<span class="number">2</span>], ..., a[n-<span class="number">2</span>]] 。</span><br><span class="line"></span><br><span class="line">给你一个元素值 互不相同 的数组 nums ，它原来是一个升序排列的数组，并按上述情形进行了多次旋转。请你找出并返回数组中的 最小元素 。</span><br><span class="line"></span><br><span class="line">你必须设计一个时间复杂度为 O(log n) 的算法解决此问题。</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">示例 <span class="number">1</span>：</span><br><span class="line"></span><br><span class="line">输入：nums = [<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">2</span>]</span><br><span class="line">输出：<span class="number">1</span></span><br><span class="line">解释：原数组为 [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>] ，旋转 <span class="number">3</span> 次得到输入数组。</span><br><span class="line">示例 <span class="number">2</span>：</span><br><span class="line"></span><br><span class="line">输入：nums = [<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>]</span><br><span class="line">输出：<span class="number">0</span></span><br><span class="line">解释：原数组为 [<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>] ，旋转 <span class="number">4</span> 次得到输入数组。</span><br><span class="line">示例 <span class="number">3</span>：</span><br><span class="line"></span><br><span class="line">输入：nums = [<span class="number">11</span>,<span class="number">13</span>,<span class="number">15</span>,<span class="number">17</span>]</span><br><span class="line">输出：<span class="number">11</span></span><br><span class="line">解释：原数组为 [<span class="number">11</span>,<span class="number">13</span>,<span class="number">15</span>,<span class="number">17</span>] ，旋转 <span class="number">4</span> 次得到输入数组。</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line"></span><br><span class="line">n == nums.length</span><br><span class="line"><span class="number">1</span> &lt;= n &lt;= <span class="number">5000</span></span><br><span class="line">-<span class="number">5000</span> &lt;= nums[i] &lt;= <span class="number">5000</span></span><br><span class="line">nums 中的所有整数 互不相同</span><br><span class="line">nums 原来是一个升序排序的数组，并进行了 <span class="number">1</span> 至 n 次旋转</span><br></pre></td></tr></table></figure><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>二分查找的进阶版</p><p>我们先将数组分为以下两种情况：</p><p>情况1：（正常的升序数组）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[1,2,3,4,5,6,7,8]</span><br></pre></td></tr></table></figure><p>情况2：（不正常）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[5,6,7,8,1,2,3,4]</span><br></pre></td></tr></table></figure><p>对于以上两种情况，如何保证我们的二分是正确的呢？</p><p><strong>如果</strong> <code>**左 &gt; 中 &amp;&amp; 中 &lt; 右**</code><strong>：</strong></p><p>这时候一定是<code>情况2</code>，而且最小值在左半边（即<code>左</code>和<code>中</code>之间），要收缩<code>右边界</code>。</p><p><strong>如果</strong> <code>**左 &lt; 中 &amp;&amp; 中 &gt; 右**</code><strong>：</strong></p><p>这时候也是<code>情况2</code>，而且最小值在右半边（即<code>中</code>和<code>右</code>之间），要收缩<code>左边界</code>。</p><p><strong>如果</strong> <code>**左 &lt; 中 &amp;&amp; 中 &lt; 右**</code><strong>：</strong></p><p>这时候 <code>[左，右]</code>这个区间内一定是升序的，最小值在左边，要收缩<code>右边界</code>。</p><p>观察发现，只要<code>中 &lt; 右</code>，都是收缩<code>右边界</code>。</p><p>其余情况则收缩<code>左边界</code>。</p><p>以上是三种合法的情况：不存在其他的可能性。</p><p>其中循环不变式是：<code>left &lt; right</code></p><p>由于<code>min = (left + right) &gt;&gt; 1</code>是向下取整的，因此，有<code>nums[left] &lt;= num[mid]</code>，且<code>nums[mid] ≠ nums[right]</code> 。</p><p>这是左闭右开区间。 </p><p><strong>分析以下边界条件</strong></p><p>如果只有只有<strong>一个数</strong>，</p><p>则不会进入while循环，直接输出<code>nums[left]</code></p><p>如果剩下<strong>两个数</strong>，</p><p>那么有：<code>left = right = right - 1</code>、<code>nums[left] = nums[mid]</code>以及<code>nums[right]</code>。</p><p>1   如果<code>nums[left] = nums[mid] &gt; nums[right]</code>，</p><p>则由上面所知：<code>中 &gt; 右</code>，收缩左边界，即执行：<code>left = mid + 1</code>。</p><p>2   如果<code>nums[left] = nums[mid] &lt; nums[right]</code>，</p><p>则由上面所知：<code>中 &lt; 右</code>，收缩右边界，即执行：<code>right = mid</code></p><p>最后都会有<code>left = right</code>，则会退出循环，输出<code>nums[left]</code></p><p>代码如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">findMin</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        left, right = <span class="number">0</span>, <span class="built_in">len</span>(nums) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> left &lt; right:</span><br><span class="line">            mid = (left + right) &gt;&gt; <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> nums[mid] &gt; nums[right]:</span><br><span class="line">                left = mid + <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:                               </span><br><span class="line">                right = mid</span><br><span class="line">        <span class="keyword">return</span> nums[left]</span><br></pre></td></tr></table></figure><h1 id="154题"><a href="#154题" class="headerlink" title="154题"></a>154题</h1><p>本题和<a href="https://leetcode.cn/problems/find-minimum-in-rotated-sorted-array-ii/">154. 寻找旋转排序数组中的最小值 II</a> 有类似的解法</p><p>只不过，154里面有重复的元素。</p><p>因此，只需在<code>nums[mid] = nums[right]</code>的时候，移动<code>右边界</code>即可。</p><p>代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">findMin</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        left, right = <span class="number">0</span>, <span class="built_in">len</span>(nums) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> left &lt; right:</span><br><span class="line">            mid = (left + right) &gt;&gt; <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> nums[mid] &gt; nums[right]:</span><br><span class="line">                left = mid + <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> nums[mid] &lt; nums[right]:</span><br><span class="line">                right = mid</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                right -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> nums[left]</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【lc】课程表</title>
      <link href="/2023/10/01/%E3%80%90lc%E3%80%91%E8%AF%BE%E7%A8%8B%E8%A1%A8/"/>
      <url>/2023/10/01/%E3%80%90lc%E3%80%91%E8%AF%BE%E7%A8%8B%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<p>题目</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">你这个学期必须选修 numCourses 门课程，记为 <span class="number">0</span> 到 numCourses - <span class="number">1</span> 。</span><br><span class="line">在选修某些课程之前需要一些先修课程。 先修课程按数组 prerequisites 给出，其中 prerequisites[i] = [ai, bi] ，表示如果要学习课程 ai 则 必须 先学习课程  bi 。</span><br><span class="line">例如，先修课程对 [<span class="number">0</span>, <span class="number">1</span>] 表示：想要学习课程 <span class="number">0</span> ，你需要先完成课程 <span class="number">1</span> 。</span><br><span class="line">请你判断是否可能完成所有课程的学习？如果可以，返回 true ；否则，返回 false 。</span><br><span class="line"></span><br><span class="line">示例 <span class="number">1</span>：</span><br><span class="line">输入：numCourses = <span class="number">2</span>, prerequisites = [[<span class="number">1</span>,<span class="number">0</span>]]</span><br><span class="line">输出：true</span><br><span class="line">解释：总共有 <span class="number">2</span> 门课程。学习课程 <span class="number">1</span> 之前，你需要完成课程 <span class="number">0</span> 。这是可能的</span><br><span class="line"></span><br><span class="line">示例 <span class="number">2</span>：</span><br><span class="line">输入：numCourses = <span class="number">2</span>, prerequisites = [[<span class="number">1</span>,<span class="number">0</span>],[<span class="number">0</span>,<span class="number">1</span>]]</span><br><span class="line">输出：false</span><br><span class="line">解释：总共有 <span class="number">2</span> 门课程。学习课程 <span class="number">1</span> 之前，你需要先完成课程 <span class="number">0</span> ；并且学习课程 <span class="number">0</span> 之前，你还应先完成课程 <span class="number">1</span> 。这是不可能的。</span><br><span class="line"> </span><br><span class="line">提示：</span><br><span class="line"><span class="number">1</span> &lt;= numCourses &lt;= <span class="number">2000</span></span><br><span class="line"><span class="number">0</span> &lt;= prerequisites.length &lt;= <span class="number">5000</span></span><br><span class="line">prerequisites[i].length == <span class="number">2</span></span><br><span class="line"><span class="number">0</span> &lt;= ai, bi &lt; numCourses</span><br><span class="line">prerequisites[i] 中的所有课程对 互不相同</span><br></pre></td></tr></table></figure><p>思路：</p><p>考察知识点是检测一个图是否是有向无环图</p><p>先得到点的入度以及图的邻接表</p><p>然后将所有入度为0的点入队列，之后一个一个取出，在将所有相邻的点的入度 -1 </p><p>不停的将入度为0的点入队</p><p>代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">canFinish</span>(<span class="params">self, numCourses: <span class="built_in">int</span>, prerequisites: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        indegrees = [<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(numCourses)]</span><br><span class="line">        adjacency = [[] <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(numCourses)]</span><br><span class="line">        queue = deque()</span><br><span class="line">        <span class="comment"># 得到入度表和邻接表</span></span><br><span class="line">        <span class="keyword">for</span> cur, pre <span class="keyword">in</span> prerequisites:</span><br><span class="line">            indegrees[cur] += <span class="number">1</span></span><br><span class="line">            adjacency[pre].append(cur)</span><br><span class="line">        <span class="comment"># 将所有入度为0的节点入队列</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(indegrees)):</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> indegrees[i]: queue.append(i)</span><br><span class="line">        <span class="comment"># 利用队列进行广度优先遍历</span></span><br><span class="line">        <span class="keyword">while</span> queue:</span><br><span class="line">            pre = queue.popleft()</span><br><span class="line">            numCourses -= <span class="number">1</span></span><br><span class="line">            <span class="comment"># 将其相邻的节点的入度 -1</span></span><br><span class="line">            <span class="keyword">for</span> cur <span class="keyword">in</span> adjacency[pre]:</span><br><span class="line">                indegrees[cur] -= <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> indegrees[cur]: queue.append(cur)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">not</span> numCourses</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【lc】最大单词长度乘积</title>
      <link href="/2023/10/01/%E3%80%90lc%E3%80%91%E6%9C%80%E5%A4%A7%E5%8D%95%E8%AF%8D%E9%95%BF%E5%BA%A6%E4%B9%98%E7%A7%AF/"/>
      <url>/2023/10/01/%E3%80%90lc%E3%80%91%E6%9C%80%E5%A4%A7%E5%8D%95%E8%AF%8D%E9%95%BF%E5%BA%A6%E4%B9%98%E7%A7%AF/</url>
      
        <content type="html"><![CDATA[<p>题目</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">给你一个字符串数组 words ，找出并返回 length(words[i]) * length(words[j]) 的最大值，并且这两个单词不含有公共字母。如果不存在这样的两个单词，返回 <span class="number">0</span> 。</span><br><span class="line"></span><br><span class="line">示例 <span class="number">1</span></span><br><span class="line">输入：words = [<span class="string">&quot;abcw&quot;</span>,<span class="string">&quot;baz&quot;</span>,<span class="string">&quot;foo&quot;</span>,<span class="string">&quot;bar&quot;</span>,<span class="string">&quot;xtfn&quot;</span>,<span class="string">&quot;abcdef&quot;</span>]</span><br><span class="line">输出：<span class="number">16</span> </span><br><span class="line">解释：这两个单词为 <span class="string">&quot;abcw&quot;</span>, <span class="string">&quot;xtfn&quot;</span>。</span><br><span class="line"></span><br><span class="line">示例 <span class="number">2</span>：</span><br><span class="line">输入：words = [<span class="string">&quot;a&quot;</span>,<span class="string">&quot;ab&quot;</span>,<span class="string">&quot;abc&quot;</span>,<span class="string">&quot;d&quot;</span>,<span class="string">&quot;cd&quot;</span>,<span class="string">&quot;bcd&quot;</span>,<span class="string">&quot;abcd&quot;</span>]</span><br><span class="line">输出：<span class="number">4</span> </span><br><span class="line">解释：这两个单词为 <span class="string">&quot;ab&quot;</span>, <span class="string">&quot;cd&quot;</span>。</span><br><span class="line"></span><br><span class="line">示例 <span class="number">3</span>：</span><br><span class="line">输入：words = [<span class="string">&quot;a&quot;</span>,<span class="string">&quot;aa&quot;</span>,<span class="string">&quot;aaa&quot;</span>,<span class="string">&quot;aaaa&quot;</span>]</span><br><span class="line">输出：<span class="number">0</span> </span><br><span class="line">解释：不存在这样的两个单词。</span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line"><span class="number">2</span> &lt;= words.length &lt;= <span class="number">1000</span></span><br><span class="line"><span class="number">1</span> &lt;= words[i].length &lt;= <span class="number">1000</span></span><br><span class="line">words[i] 仅包含小写字母</span><br></pre></td></tr></table></figure><p>思路：</p><p>利用位运算，让每一位代表一个字母</p><p>然后让两个相与</p><p>代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maxProduct</span>(<span class="params">self, words: <span class="type">List</span>[<span class="built_in">str</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        mask = [<span class="number">0</span>] * <span class="built_in">len</span>(words)</span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i, s <span class="keyword">in</span> <span class="built_in">enumerate</span>(words):</span><br><span class="line">            <span class="keyword">for</span> c <span class="keyword">in</span> s:</span><br><span class="line">                mask[i] |= <span class="number">1</span> &lt;&lt; (<span class="built_in">ord</span>(c) - <span class="built_in">ord</span>(<span class="string">&#x27;a&#x27;</span>))</span><br><span class="line">            <span class="keyword">for</span> j, t <span class="keyword">in</span> <span class="built_in">enumerate</span>(words[:i]):</span><br><span class="line">                <span class="keyword">if</span> (mask[i] &amp; mask[j]) == <span class="number">0</span>:</span><br><span class="line">                    res = <span class="built_in">max</span>(res, <span class="built_in">len</span>(s) * <span class="built_in">len</span>(t))</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【lc】岛屿数量</title>
      <link href="/2023/10/01/%E3%80%90lc%E3%80%91%E5%B2%9B%E5%B1%BF%E6%95%B0%E9%87%8F/"/>
      <url>/2023/10/01/%E3%80%90lc%E3%80%91%E5%B2%9B%E5%B1%BF%E6%95%B0%E9%87%8F/</url>
      
        <content type="html"><![CDATA[<p>题目</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">给你一个由 <span class="string">&#x27;1&#x27;</span>（陆地）和 <span class="string">&#x27;0&#x27;</span>（水）组成的的二维网格，请你计算网格中岛屿的数量。</span><br><span class="line"></span><br><span class="line">岛屿总是被水包围，并且每座岛屿只能由水平方向和/或竖直方向上相邻的陆地连接形成。</span><br><span class="line"></span><br><span class="line">此外，你可以假设该网格的四条边均被水包围。</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">示例 <span class="number">1</span>：</span><br><span class="line"></span><br><span class="line">输入：grid = [</span><br><span class="line">  [<span class="string">&quot;1&quot;</span>,<span class="string">&quot;1&quot;</span>,<span class="string">&quot;1&quot;</span>,<span class="string">&quot;1&quot;</span>,<span class="string">&quot;0&quot;</span>],</span><br><span class="line">  [<span class="string">&quot;1&quot;</span>,<span class="string">&quot;1&quot;</span>,<span class="string">&quot;0&quot;</span>,<span class="string">&quot;1&quot;</span>,<span class="string">&quot;0&quot;</span>],</span><br><span class="line">  [<span class="string">&quot;1&quot;</span>,<span class="string">&quot;1&quot;</span>,<span class="string">&quot;0&quot;</span>,<span class="string">&quot;0&quot;</span>,<span class="string">&quot;0&quot;</span>],</span><br><span class="line">  [<span class="string">&quot;0&quot;</span>,<span class="string">&quot;0&quot;</span>,<span class="string">&quot;0&quot;</span>,<span class="string">&quot;0&quot;</span>,<span class="string">&quot;0&quot;</span>]</span><br><span class="line">]</span><br><span class="line">输出：<span class="number">1</span></span><br><span class="line">示例 <span class="number">2</span>：</span><br><span class="line"></span><br><span class="line">输入：grid = [</span><br><span class="line">  [<span class="string">&quot;1&quot;</span>,<span class="string">&quot;1&quot;</span>,<span class="string">&quot;0&quot;</span>,<span class="string">&quot;0&quot;</span>,<span class="string">&quot;0&quot;</span>],</span><br><span class="line">  [<span class="string">&quot;1&quot;</span>,<span class="string">&quot;1&quot;</span>,<span class="string">&quot;0&quot;</span>,<span class="string">&quot;0&quot;</span>,<span class="string">&quot;0&quot;</span>],</span><br><span class="line">  [<span class="string">&quot;0&quot;</span>,<span class="string">&quot;0&quot;</span>,<span class="string">&quot;1&quot;</span>,<span class="string">&quot;0&quot;</span>,<span class="string">&quot;0&quot;</span>],</span><br><span class="line">  [<span class="string">&quot;0&quot;</span>,<span class="string">&quot;0&quot;</span>,<span class="string">&quot;0&quot;</span>,<span class="string">&quot;1&quot;</span>,<span class="string">&quot;1&quot;</span>]</span><br><span class="line">]</span><br><span class="line">输出：<span class="number">3</span></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line"></span><br><span class="line">m == grid.length</span><br><span class="line">n == grid[i].length</span><br><span class="line"><span class="number">1</span> &lt;= m, n &lt;= <span class="number">300</span></span><br><span class="line">grid[i][j] 的值为 <span class="string">&#x27;0&#x27;</span> 或 <span class="string">&#x27;1&#x27;</span></span><br></pre></td></tr></table></figure><p>思路：<br>利用深度优先搜索，遍历所有节点，并且搜到底，搜到底之后记录数 + 1</p><p>代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">dirs = [[<span class="number">1</span>, <span class="number">0</span>], [-<span class="number">1</span>, <span class="number">0</span>], [<span class="number">0</span>, <span class="number">1</span>], [<span class="number">0</span>, -<span class="number">1</span>]]</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">numIslands</span>(<span class="params">self, grid: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">str</span>]]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">r: <span class="built_in">int</span>, c: <span class="built_in">int</span></span>):</span><br><span class="line">            <span class="keyword">if</span> r &lt; <span class="number">0</span> <span class="keyword">or</span> r &gt;= m <span class="keyword">or</span> c &lt; <span class="number">0</span> <span class="keyword">or</span> c &gt;= n <span class="keyword">or</span> grid[r][c] == <span class="string">&#x27;0&#x27;</span> <span class="keyword">or</span> is_visited[r][c]: <span class="keyword">return</span></span><br><span class="line">            is_visited[r][c] = <span class="literal">True</span></span><br><span class="line">            <span class="keyword">for</span> d <span class="keyword">in</span> dirs:</span><br><span class="line">                dfs(r + d[<span class="number">0</span>], c + d[<span class="number">1</span>])</span><br><span class="line">        m = <span class="built_in">len</span>(grid)</span><br><span class="line">        n = <span class="built_in">len</span>(grid[<span class="number">0</span>])</span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        is_visited = [[<span class="literal">False</span>] * n <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(m)]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">                <span class="keyword">if</span> is_visited[i][j] <span class="keyword">or</span> grid[i][j] == <span class="string">&#x27;0&#x27;</span>:</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                dfs(i, j)</span><br><span class="line">                res += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><p>考点</p><p>图论 深搜 广搜</p>]]></content>
      
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【lc】环和杆</title>
      <link href="/2023/10/01/%E3%80%90lc%E3%80%91%E7%8E%AF%E5%92%8C%E6%9D%86/"/>
      <url>/2023/10/01/%E3%80%90lc%E3%80%91%E7%8E%AF%E5%92%8C%E6%9D%86/</url>
      
        <content type="html"><![CDATA[<p>题目</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">总计有 n 个环，环的颜色可以是红、绿、蓝中的一种。这些环分别穿在 <span class="number">10</span> 根编号为 <span class="number">0</span> 到 <span class="number">9</span> 的杆上。</span><br><span class="line"></span><br><span class="line">给你一个长度为 2n 的字符串 rings ，表示这 n 个环在杆上的分布。rings 中每两个字符形成一个 颜色位置对 ，用于描述每个环：</span><br><span class="line"></span><br><span class="line">第 i 对中的 第一个 字符表示第 i 个环的 颜色（<span class="string">&#x27;R&#x27;</span>、<span class="string">&#x27;G&#x27;</span>、<span class="string">&#x27;B&#x27;</span>）。</span><br><span class="line">第 i 对中的 第二个 字符表示第 i 个环的 位置，也就是位于哪根杆上（<span class="string">&#x27;0&#x27;</span> 到 <span class="string">&#x27;9&#x27;</span>）。</span><br><span class="line">例如，<span class="string">&quot;R3G2B1&quot;</span> 表示：共有 n == <span class="number">3</span> 个环，红色的环在编号为 <span class="number">3</span> 的杆上，绿色的环在编号为 <span class="number">2</span> 的杆上，蓝色的环在编号为 <span class="number">1</span> 的杆上。</span><br><span class="line"></span><br><span class="line">找出所有集齐 全部三种颜色 环的杆，并返回这种杆的数量。</span><br></pre></td></tr></table></figure><p>思路：位运算 <a href="https://leetcode.cn/problems/rings-and-rods/solutions/2508862/python3javacgorusttypescript-yi-ti-yi-ji-p7qi/">ylb的题解</a></p><p>利用三个二进制位，每一位代表每个颜色</p><p>比如R代表1，G代表2，B代表4</p><p>每个数对，(i, j)：i是环的颜色，j是哪一个杆</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">countPoints</span>(<span class="params">self, rings: <span class="built_in">str</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        mask = [<span class="number">0</span>] * <span class="number">10</span></span><br><span class="line">        d = &#123;<span class="string">&quot;R&quot;</span>: <span class="number">1</span>, <span class="string">&quot;G&quot;</span>: <span class="number">2</span>, <span class="string">&quot;B&quot;</span>: <span class="number">4</span>&#125;</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(rings), <span class="number">2</span>):</span><br><span class="line">            c = rings[i]</span><br><span class="line">            j = <span class="built_in">int</span>(rings[i + <span class="number">1</span>])</span><br><span class="line">            mask[j] |= d[c]</span><br><span class="line">        <span class="keyword">return</span> mask.count(<span class="number">7</span>)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【lc】合法分组的最小组数</title>
      <link href="/2023/10/01/%E3%80%90lc%E3%80%91%E5%90%88%E6%B3%95%E5%88%86%E7%BB%84%E7%9A%84%E6%9C%80%E5%B0%8F%E7%BB%84%E6%95%B0/"/>
      <url>/2023/10/01/%E3%80%90lc%E3%80%91%E5%90%88%E6%B3%95%E5%88%86%E7%BB%84%E7%9A%84%E6%9C%80%E5%B0%8F%E7%BB%84%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<p>题目</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">给你一个长度为 n 下标从 0 开始的整数数组 nums 。</span><br><span class="line"></span><br><span class="line">我们想将下标进行分组，使得 [0, n - 1] 内所有下标 i 都 恰好 被分到其中一组。</span><br><span class="line"></span><br><span class="line">如果以下条件成立，我们说这个分组方案是合法的：</span><br><span class="line"></span><br><span class="line">对于每个组 g ，同一组内所有下标在 nums 中对应的数值都相等。</span><br><span class="line">对于任意两个组 g1 和 g2 ，两个组中 下标数量 的 差值不超过 1 。</span><br><span class="line">请你返回一个整数，表示得到一个合法分组方案的 最少 组数。</span><br></pre></td></tr></table></figure><p><a href="https://www.bilibili.com/video/BV12w411B7ia/?spm_id_from=333.999.0.0&vd_source=46afff3dc31707282eed5b4c9dfd7b6b">思路</a>：</p><p>不管怎么分，最后的组内个数都是k，或者都是k和k+1</p><p>枚举k的值，对于相同数字a，假设a有c个，假设q &#x3D; c &#x2F; k（下取整），r &#x3D; c % k</p><p>如果 q ≥ r，则k符合条件，如果q &lt; r，则k不符合条件</p><p>那么对于c个数，组内最少分k个的情况下， 则有c&#x2F;(k+1)（上取整）组</p><p>最后累加即可</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def minGroupsForValidAssignment(self, nums: List[int]) -&gt; int:</span><br><span class="line">        # 从大到小枚举k的值，检查每个相同的数的组数是否符合条件</span><br><span class="line">        cnt = list(Counter(nums).values())</span><br><span class="line">        mn = min(cnt)</span><br><span class="line">        res = float(inf)</span><br><span class="line">        for k in range(mn, 0, -1):</span><br><span class="line">            flag = True</span><br><span class="line">            tmp = 0</span><br><span class="line">            for c in cnt:</span><br><span class="line">                # divmod函数可以快速计算出商和余数</span><br><span class="line">                q, r = divmod(c, k)</span><br><span class="line">                # q = floor(c / k)</span><br><span class="line">                # r = c % k</span><br><span class="line">                if q &lt; r:</span><br><span class="line">                    flag = False</span><br><span class="line">                    break</span><br><span class="line">                tmp += ceil(c / (k + 1))</span><br><span class="line">            if flag:</span><br><span class="line">                res = min(res, tmp)</span><br><span class="line">        return res</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【lc】求一个整数的惩罚数</title>
      <link href="/2023/10/01/%E3%80%90lc%E3%80%91%E6%B1%82%E4%B8%80%E4%B8%AA%E6%95%B4%E6%95%B0%E7%9A%84%E6%83%A9%E7%BD%9A%E6%95%B0/"/>
      <url>/2023/10/01/%E3%80%90lc%E3%80%91%E6%B1%82%E4%B8%80%E4%B8%AA%E6%95%B4%E6%95%B0%E7%9A%84%E6%83%A9%E7%BD%9A%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<p>题目</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">给你一个正整数 n ，请你返回 n 的 惩罚数 。</span><br><span class="line"></span><br><span class="line">n 的 惩罚数 定义为所有满足以下条件 i 的数的平方和：</span><br><span class="line"></span><br><span class="line">1 &lt;= i &lt;= n</span><br><span class="line">i * i 的十进制表示的字符串可以分割成若干连续子字符串，且这些子字符串对应的整数值之和等于 i 。</span><br><span class="line"></span><br><span class="line">示例 1：</span><br><span class="line"></span><br><span class="line">输入：n = 10</span><br><span class="line">输出：182</span><br><span class="line">解释：总共有 3 个整数 i 满足要求：</span><br><span class="line">- 1 ，因为 1 * 1 = 1</span><br><span class="line">- 9 ，因为 9 * 9 = 81 ，且 81 可以分割成 8 + 1 。</span><br><span class="line">- 10 ，因为 10 * 10 = 100 ，且 100 可以分割成 10 + 0 。</span><br><span class="line">因此，10 的惩罚数为 1 + 81 + 100 = 182</span><br><span class="line">示例 2：</span><br><span class="line"></span><br><span class="line">输入：n = 37</span><br><span class="line">输出：1478</span><br><span class="line">解释：总共有 4 个整数 i 满足要求：</span><br><span class="line">- 1 ，因为 1 * 1 = 1</span><br><span class="line">- 9 ，因为 9 * 9 = 81 ，且 81 可以分割成 8 + 1 。</span><br><span class="line">- 10 ，因为 10 * 10 = 100 ，且 100 可以分割成 10 + 0 。</span><br><span class="line">- 36 ，因为 36 * 36 = 1296 ，且 1296 可以分割成 1 + 29 + 6 。</span><br><span class="line">因此，37 的惩罚数为 1 + 81 + 100 + 1296 = 1478</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line"></span><br><span class="line">1 &lt;= n &lt;= 1000</span><br></pre></td></tr></table></figure><p>思路</p><p>遍历1到n，依次检查每个数是否符合惩罚数的条件，然后累加即可</p><p>如何检查呢？</p><p>可以利用递归，就是递归字符串的截取位置，来判断</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">check</span>(<span class="params">s: <span class="built_in">str</span>, i: <span class="built_in">int</span>, x: <span class="built_in">int</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">    m = <span class="built_in">len</span>(s)</span><br><span class="line">    <span class="keyword">if</span> i &gt;= m:</span><br><span class="line">        <span class="keyword">return</span> x == <span class="number">0</span></span><br><span class="line">    y = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i, m):</span><br><span class="line">        y = y * <span class="number">10</span> + <span class="built_in">int</span>(s[j])</span><br><span class="line">        <span class="keyword">if</span> y &gt; x:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">if</span> check(s, j + <span class="number">1</span>, x - y):</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure><p>考点</p><p>递归</p>]]></content>
      
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【lc】多数元素</title>
      <link href="/2023/10/01/%E3%80%90lc%E3%80%91%E5%A4%9A%E6%95%B0%E5%85%83%E7%B4%A0/"/>
      <url>/2023/10/01/%E3%80%90lc%E3%80%91%E5%A4%9A%E6%95%B0%E5%85%83%E7%B4%A0/</url>
      
        <content type="html"><![CDATA[<p>题目</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">给定一个大小为 n 的数组 nums ，返回其中的多数元素。多数元素是指在数组中出现次数 大于 ⌊ n/2 ⌋ 的元素。</span><br><span class="line">你可以假设数组是非空的，并且给定的数组总是存在多数元素。</span><br><span class="line"></span><br><span class="line">示例 1：</span><br><span class="line">输入：nums = [3,2,3]</span><br><span class="line">输出：3</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入：nums = [2,2,1,1,1,2,2]</span><br><span class="line">输出：2</span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line">n == nums.length</span><br><span class="line">1 &lt;= n &lt;= 5 * 104</span><br><span class="line">-109 &lt;= nums[i] &lt;= 109</span><br><span class="line"></span><br><span class="line">进阶：尝试设计时间复杂度为 O(n)、空间复杂度为 O(1) 的算法解决此问题。</span><br></pre></td></tr></table></figure><p>思路</p><p>题目中定义的多数元素出现的次数大于<code>⌊ n/2 ⌋</code>，也就是说数组中<strong>一半</strong>以上的</p><p>我们可以使用<strong>多数投票算法</strong>来解决。</p><p><a href="https://zh.wikipedia.org/zh-hans/%E5%A4%9A%E6%95%B0%E6%8A%95%E7%A5%A8%E7%AE%97%E6%B3%95">多数投票算法</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">该算法在其局部变量中存储一个数组元素和一个计数器，计数器初始化为 0。然后对数组进行遍历操作，在遍历到元素 x 的时候：如果计数器为 0，则算法将 x 存储到数组元素变量，并将计数器设置为 1。 否则，它将 x 与存储的元素进行比较，然后递增计数器（如果它们相等）或递减计数器（不相等）。 在此过程结束时，如果数组中存在占多数的元素，则它将是存储的数组元素变量的值。</span><br><span class="line">算法可以用伪代码如下表示：</span><br><span class="line"></span><br><span class="line">- 初始化元素m并给计数器i赋初值i = 0</span><br><span class="line">- 对于输入队列中每一个元素x：</span><br><span class="line">  - 若i = 0, 那么 m = x and i = 1</span><br><span class="line">  - 否则若m = x, 那么 i = i + 1</span><br><span class="line">  - 否则 i = i − 1</span><br><span class="line">- 返回 m</span><br></pre></td></tr></table></figure><p>代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">majorityElement</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        i = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> nums:</span><br><span class="line">            <span class="keyword">if</span> i == <span class="number">0</span>: m = x</span><br><span class="line">            i += <span class="number">1</span> <span class="keyword">if</span> m == x <span class="keyword">else</span> -<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> m </span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【lc】将有序数组转化为二叉搜索树</title>
      <link href="/2023/10/01/%E3%80%90lc%E3%80%91%E5%B0%86%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E8%BD%AC%E5%8C%96%E4%B8%BA%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/"/>
      <url>/2023/10/01/%E3%80%90lc%E3%80%91%E5%B0%86%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E8%BD%AC%E5%8C%96%E4%B8%BA%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<p>题目</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">给你一个整数数组 nums ，其中元素已经按 升序 排列，请你将其转换为一棵 高度平衡 二叉搜索树。</span><br><span class="line">高度平衡 二叉树是一棵满足「每个节点的左右两个子树的高度差的绝对值不超过 <span class="number">1</span> 」的二叉树。</span><br><span class="line"></span><br><span class="line">示例 <span class="number">1</span>：</span><br><span class="line">输入：nums = [-<span class="number">10</span>,-<span class="number">3</span>,<span class="number">0</span>,<span class="number">5</span>,<span class="number">9</span>]</span><br><span class="line">输出：[<span class="number">0</span>,-<span class="number">3</span>,<span class="number">9</span>,-<span class="number">10</span>,null,<span class="number">5</span>]</span><br><span class="line">解释：[<span class="number">0</span>,-<span class="number">10</span>,<span class="number">5</span>,null,-<span class="number">3</span>,null,<span class="number">9</span>] 也将被视为正确答案：</span><br><span class="line"></span><br><span class="line">示例 <span class="number">2</span>：</span><br><span class="line">输入：nums = [<span class="number">1</span>,<span class="number">3</span>]</span><br><span class="line">输出：[<span class="number">3</span>,<span class="number">1</span>]</span><br><span class="line">解释：[<span class="number">1</span>,null,<span class="number">3</span>] 和 [<span class="number">3</span>,<span class="number">1</span>] 都是高度平衡二叉搜索树。</span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line"><span class="number">1</span> &lt;= nums.length &lt;= <span class="number">104</span></span><br><span class="line">-<span class="number">104</span> &lt;= nums[i] &lt;= <span class="number">104</span></span><br><span class="line">nums 按 严格递增 顺序排列</span><br></pre></td></tr></table></figure><p>思路：</p><p><strong>递归</strong>下去，每次使用<strong>中间节点</strong>作为根节点。</p><p>code</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">sortedArrayToBST</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">Optional</span>[TreeNode]:</span><br><span class="line">        <span class="keyword">return</span> self.build(nums, <span class="number">0</span>, <span class="built_in">len</span>(nums) - <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">build</span>(<span class="params">self, nums, l, r</span>):</span><br><span class="line">        <span class="keyword">if</span> l &gt; r:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        <span class="comment"># 找中间点</span></span><br><span class="line">        mid = l + r &gt;&gt; <span class="number">1</span></span><br><span class="line">        <span class="comment"># 根据值，生成一个节点</span></span><br><span class="line">        ans = TreeNode(nums[mid])</span><br><span class="line">        <span class="comment"># 这个节点的左右子节点</span></span><br><span class="line">        ans.left = self.build(nums, l, mid - <span class="number">1</span>)</span><br><span class="line">        ans.right = self.build(nums, mid + <span class="number">1</span>, r)</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure><p>考点</p><p>递归</p>]]></content>
      
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【考研】距离复试还有十来天</title>
      <link href="/2023/03/28/%E3%80%90%E8%80%83%E7%A0%94%E3%80%91%E8%B7%9D%E7%A6%BB%E5%A4%8D%E8%AF%95%E8%BF%98%E6%9C%89%E5%8D%81%E6%9D%A5%E5%A4%A9/"/>
      <url>/2023/03/28/%E3%80%90%E8%80%83%E7%A0%94%E3%80%91%E8%B7%9D%E7%A6%BB%E5%A4%8D%E8%AF%95%E8%BF%98%E6%9C%89%E5%8D%81%E6%9D%A5%E5%A4%A9/</url>
      
        <content type="html"><![CDATA[<p>ECNU发通知说四月上旬前完成复试工作，那也就是大概三月底复试了。。</p><p>过两天还要去上海，好远。。</p><p>有些慌</p><p>前一阵子一直在准备机试（机试题好难o(╥﹏╥)o</p><p>面试问题没来得及准备，，今天才开始准备，，要加把劲了</p><p>常见的英语问题就那样吧，自我介绍得好好背背</p><p>简历上的项目要回顾一下（花费三天大概？</p><p>准备把面试老师往<strong>区块链</strong>方向上引导，有个好兄弟研究生是做的这个，我也感觉区块链方向挺有意思的</p><p>了解一下区块链相关知识以及准备一下可能的面试问题（大概三天？</p><p>至于数据库。。。好难啊</p><p>408的大概看看（两天？</p><p>md，最后加把劲吧！</p>]]></content>
      
      
      
        <tags>
            
            <tag> 考研 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【考研】写点什么</title>
      <link href="/2023/03/06/%E3%80%90%E8%80%83%E7%A0%94%E3%80%91%E5%86%99%E7%82%B9%E4%BB%80%E4%B9%88/"/>
      <url>/2023/03/06/%E3%80%90%E8%80%83%E7%A0%94%E3%80%91%E5%86%99%E7%82%B9%E4%BB%80%E4%B9%88/</url>
      
        <content type="html"><![CDATA[<p>太容易在学习中迷失方向，原本要去学A，结果过程中看到了B，就去学B，学一会发现学不下去，就回到A</p><p>有些混乱了，应该停下来捋一捋了</p><p>目前的最主要的任务就是准备复试，而复试又分为机试和面试。如果是线上复试，则机试不算分，线下就算分数。</p><p>今年大概率线下。机试很重要了，算法笔记继续刷，目前学到了树，可是关于树的遍历什么的基本上都会，构造树、存储树还没有练习。</p><p>图的也还没有开始，最简单的dfs和bfs学了一些感觉还可以，动态规划也只学到了一些皮毛。。。</p><p>目前关于机试：</p><blockquote><p>真题只做了2018年李志的那几道题，感觉上不是太难</p><p>但是他们每年出的题差别说实话还是挺大的，不如老老实实跟着算法笔记学完。。</p></blockquote><p>面试：</p><blockquote><p>总共时间也就是30分钟左右</p><p>线上的话要讲PPT，占据八分钟，剩下20分钟左右，能问几个问题呢？大约也就是七八个吧</p><p>408、数据库+计算机学科常识（关于常识这个准备去搜索一下计算机专业的面试问题吧</p><p>项目？就说毕设吧，留几个明显的漏洞，等老师去问</p><p>比如：</p></blockquote><p>。。。。我在这里写这些干什么，应该放到【复试】面试里面写吧。。。。</p><p>困死了，睡觉了，再也不想凌晨两三点睡了，goodnight,world~</p>]]></content>
      
      
      
        <tags>
            
            <tag> 考研 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【考研】出成绩啦</title>
      <link href="/2023/02/21/%E3%80%90%E8%80%83%E7%A0%94%E3%80%91%E5%87%BA%E6%88%90%E7%BB%A9%E5%95%A6/"/>
      <url>/2023/02/21/%E3%80%90%E8%80%83%E7%A0%94%E3%80%91%E5%87%BA%E6%88%90%E7%BB%A9%E5%95%A6/</url>
      
        <content type="html"><![CDATA[<p>出成绩啦，意料之中，专业课没考好…..</p><table><thead><tr><th>总分</th><th>政治</th><th>英语</th><th>数学</th><th>专业课408</th></tr></thead><tbody><tr><td>384</td><td>60</td><td>85</td><td>140</td><td>99</td></tr></tbody></table>]]></content>
      
      
      
        <tags>
            
            <tag> 考研 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【考研】最后一个月</title>
      <link href="/2022/11/20/%E3%80%90%E8%80%83%E7%A0%94%E3%80%91%E6%9C%80%E5%90%8E%E4%B8%80%E4%B8%AA%E6%9C%88/"/>
      <url>/2022/11/20/%E3%80%90%E8%80%83%E7%A0%94%E3%80%91%E6%9C%80%E5%90%8E%E4%B8%80%E4%B8%AA%E6%9C%88/</url>
      
        <content type="html"><![CDATA[<p>11.20</p><h2 id="数学："><a href="#数学：" class="headerlink" title="数学："></a>数学：</h2><p>已经刷了03~21年真题，2套张八、李林6、一套李永乐6<br>准备继续把李永乐6套刷完，<br>刚做了李永乐第一套卷，做的过程中感觉不难，但总不是那么通透，深挖下来发现了很多知识点漏洞。希望接下来五套也能带来这样的效果吧。</p><p>听说前几年的超越选填出的挺好的，之后去做一下。<br>还有李艳芳。。。。</p><p>做卷子时的压力有些大，慌里慌张的经常犯一些算数上面的低级错误。计算能力太差了，之后写模拟不要慌，尽量不跳步骤，演草纸上也写规整一些。<br>进度：虽然进度有些慢，不过争取把每一套卷子都吃透，把该掌握的知识点都掌握到。考研题不会出的太偏，大多所谓的难题都是难在了综合性上，把每个知识点逐一击破就ok。一些题看上去咋咋呼呼，不要急，静下心来想一下这可能是在考察什么知识点，需要利用哪些结论，是不是某几个知识点的综合。<br>最重要的还是心态心态心态！！！</p><hr><h2 id="408："><a href="#408：" class="headerlink" title="408："></a>408：</h2><p>刷完了09~22真题以及三套王道模拟</p><p>真题中的一些小知识点很容易遗忘，要多回去看一看。<br>王道模拟出的大题对计组和os的考察挺深入。</p><p>之后：<br>回归王道书，穿插模拟题查漏，结合着思维导图补缺。对于408这种偏记忆的学科还是要翻来覆去的回顾</p><hr><h2 id="英语："><a href="#英语：" class="headerlink" title="英语："></a>英语：</h2><p>正在三刷英二真题，之前刷的太盲目了，之后真题里面的长难句要多留意一下。其实英二阅读的技巧性也挺强的，不要过度推理，跳出自己的思维框架，一些模糊词是不选的。<br>小作文已经写了几篇了，大作文还没来得及搞。</p><p>之后：<br>争取在11月底前把大作文也好好的看看写几篇<br>每天照常1~2篇阅读，中间穿插着小三门和完型，单词不要落下</p><hr><h2 id="政治："><a href="#政治：" class="headerlink" title="政治："></a>政治：</h2><p>肖八选择只写了4套，均分25，我太难了。。。。</p><p>月底前刷完肖八，每套选择尽量吃透<br>肖八第一套的大题平时可以读一下，为之后肖四节约时间</p><hr><h2 id="睡觉："><a href="#睡觉：" class="headerlink" title="睡觉："></a>睡觉：</h2><p>睡觉前不要再看手机了！看手机的时间都够做几道数学题了</p>]]></content>
      
      
      
        <tags>
            
            <tag> 考研 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
