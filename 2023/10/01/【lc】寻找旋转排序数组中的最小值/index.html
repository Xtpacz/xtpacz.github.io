<!DOCTYPE html><html><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content=""><title>【lc】寻找旋转排序数组中的最小值 | Xtpacz's Blog</title><link rel="stylesheet" type="text/css" href="/css/normalize.css"><link rel="stylesheet" type="text/css" href="/css/highlight.css"><link rel="stylesheet" type="text/css" href="/css/very-simple.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/font-awesome/4.5.0/css/font-awesome.min.css"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><meta name="generator" content="Hexo 7.1.1"></head><body><!-- include the sidebar--><!-- include ./includes/sidebar.jade--><!-- Blog title and subtitle--><header><div class="container header"><a id="logo" href="/." class="title">Xtpacz's Blog</a><span class="subtitle"></span><label id="toggle-menu" for="menu" onclick><i class="fa fa-bars"></i></label></div></header><!-- use checkbox hack for toggle nav-bar on small screens--><input id="menu" type="checkbox"><!-- Navigation Links--><nav id="nav"><div class="container"><a href="/" class="sidebar-nav-item active">Home</a><a href="/archives" class="sidebar-nav-item">Archives</a><a href="/about.html" class="sidebar-nav-item">About</a></div></nav><div id="header-margin-bar"></div><!-- gallery that comes before the header--><div class="wrapper"><div class="container post-header"><h1>【lc】寻找旋转排序数组中的最小值</h1></div></div><div class="wrapper"><div class="container meta"><div class="post-time">2023-10-01</div></div></div><article><div class="container post"><p>题目</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">已知一个长度为 n 的数组，预先按照升序排列，经由 <span class="number">1</span> 到 n 次 旋转 后，得到输入数组。例如，原数组 nums = [<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>] 在变化后可能得到：</span><br><span class="line">若旋转 <span class="number">4</span> 次，则可以得到 [<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>]</span><br><span class="line">若旋转 <span class="number">7</span> 次，则可以得到 [<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>]</span><br><span class="line">注意，数组 [a[<span class="number">0</span>], a[<span class="number">1</span>], a[<span class="number">2</span>], ..., a[n-<span class="number">1</span>]] 旋转一次 的结果为数组 [a[n-<span class="number">1</span>], a[<span class="number">0</span>], a[<span class="number">1</span>], a[<span class="number">2</span>], ..., a[n-<span class="number">2</span>]] 。</span><br><span class="line"></span><br><span class="line">给你一个元素值 互不相同 的数组 nums ，它原来是一个升序排列的数组，并按上述情形进行了多次旋转。请你找出并返回数组中的 最小元素 。</span><br><span class="line"></span><br><span class="line">你必须设计一个时间复杂度为 O(log n) 的算法解决此问题。</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">示例 <span class="number">1</span>：</span><br><span class="line"></span><br><span class="line">输入：nums = [<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">2</span>]</span><br><span class="line">输出：<span class="number">1</span></span><br><span class="line">解释：原数组为 [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>] ，旋转 <span class="number">3</span> 次得到输入数组。</span><br><span class="line">示例 <span class="number">2</span>：</span><br><span class="line"></span><br><span class="line">输入：nums = [<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>]</span><br><span class="line">输出：<span class="number">0</span></span><br><span class="line">解释：原数组为 [<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>] ，旋转 <span class="number">4</span> 次得到输入数组。</span><br><span class="line">示例 <span class="number">3</span>：</span><br><span class="line"></span><br><span class="line">输入：nums = [<span class="number">11</span>,<span class="number">13</span>,<span class="number">15</span>,<span class="number">17</span>]</span><br><span class="line">输出：<span class="number">11</span></span><br><span class="line">解释：原数组为 [<span class="number">11</span>,<span class="number">13</span>,<span class="number">15</span>,<span class="number">17</span>] ，旋转 <span class="number">4</span> 次得到输入数组。</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line"></span><br><span class="line">n == nums.length</span><br><span class="line"><span class="number">1</span> &lt;= n &lt;= <span class="number">5000</span></span><br><span class="line">-<span class="number">5000</span> &lt;= nums[i] &lt;= <span class="number">5000</span></span><br><span class="line">nums 中的所有整数 互不相同</span><br><span class="line">nums 原来是一个升序排序的数组，并进行了 <span class="number">1</span> 至 n 次旋转</span><br></pre></td></tr></table></figure>



<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>二分查找的进阶版</p>
<p>我们先将数组分为以下两种情况：</p>
<p>情况1：（正常的升序数组）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[1,2,3,4,5,6,7,8]</span><br></pre></td></tr></table></figure>

<p>情况2：（不正常）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[5,6,7,8,1,2,3,4]</span><br></pre></td></tr></table></figure>



<p>对于以上两种情况，如何保证我们的二分是正确的呢？</p>
<p><strong>如果</strong> <code>**左 &gt; 中 &amp;&amp; 中 &lt; 右**</code><strong>：</strong></p>
<p>这时候一定是<code>情况2</code>，而且最小值在左半边（即<code>左</code>和<code>中</code>之间），要收缩<code>右边界</code>。</p>
<p><strong>如果</strong> <code>**左 &lt; 中 &amp;&amp; 中 &gt; 右**</code><strong>：</strong></p>
<p>这时候也是<code>情况2</code>，而且最小值在右半边（即<code>中</code>和<code>右</code>之间），要收缩<code>左边界</code>。</p>
<p><strong>如果</strong> <code>**左 &lt; 中 &amp;&amp; 中 &lt; 右**</code><strong>：</strong></p>
<p>这时候 <code>[左，右]</code>这个区间内一定是升序的，最小值在左边，要收缩<code>右边界</code>。</p>
<p>观察发现，只要<code>中 &lt; 右</code>，都是收缩<code>右边界</code>。</p>
<p>其余情况则收缩<code>左边界</code>。</p>
<p>以上是三种合法的情况：不存在其他的可能性。</p>
<p>其中循环不变式是：<code>left &lt; right</code></p>
<p>由于<code>min = (left + right) &gt;&gt; 1</code>是向下取整的，因此，有<code>nums[left] &lt;= num[mid]</code>，且<code>nums[mid] ≠ nums[right]</code> 。</p>
<p>这是左闭右开区间。 </p>
<p><strong>分析以下边界条件</strong></p>
<p>如果只有只有<strong>一个数</strong>，</p>
<p>则不会进入while循环，直接输出<code>nums[left]</code></p>
<p>如果剩下<strong>两个数</strong>，</p>
<p>那么有：<code>left = right = right - 1</code>、<code>nums[left] = nums[mid]</code>以及<code>nums[right]</code>。</p>
<p>1   如果<code>nums[left] = nums[mid] &gt; nums[right]</code>，</p>
<p>则由上面所知：<code>中 &gt; 右</code>，收缩左边界，即执行：<code>left = mid + 1</code>。</p>
<p>2   如果<code>nums[left] = nums[mid] &lt; nums[right]</code>，</p>
<p>则由上面所知：<code>中 &lt; 右</code>，收缩右边界，即执行：<code>right = mid</code></p>
<p>最后都会有<code>left = right</code>，则会退出循环，输出<code>nums[left]</code></p>
<p>代码如下</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">findMin</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        left, right = <span class="number">0</span>, <span class="built_in">len</span>(nums) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> left &lt; right:</span><br><span class="line">            mid = (left + right) &gt;&gt; <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> nums[mid] &gt; nums[right]:</span><br><span class="line">                left = mid + <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:                               </span><br><span class="line">                right = mid</span><br><span class="line">        <span class="keyword">return</span> nums[left]</span><br></pre></td></tr></table></figure>



<h1 id="154题"><a href="#154题" class="headerlink" title="154题"></a>154题</h1><p>本题和<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/find-minimum-in-rotated-sorted-array-ii/">154. 寻找旋转排序数组中的最小值 II</a> 有类似的解法</p>
<p>只不过，154里面有重复的元素。</p>
<p>因此，只需在<code>nums[mid] = nums[right]</code>的时候，移动<code>右边界</code>即可。</p>
<p>代码如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">findMin</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        left, right = <span class="number">0</span>, <span class="built_in">len</span>(nums) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> left &lt; right:</span><br><span class="line">            mid = (left + right) &gt;&gt; <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> nums[mid] &gt; nums[right]:</span><br><span class="line">                left = mid + <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> nums[mid] &lt; nums[right]:</span><br><span class="line">                right = mid</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                right -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> nums[left]</span><br></pre></td></tr></table></figure>
</div><!-- comment system--><div class="container"><hr></div></article><footer id="footer"><div class="container"><div class="bar"><div class="social"><a href="/atom.xml" target="_blank"><i class="fa fa-rss"></i></a></div><div class="footer">© 2024 <a href="/" rel="nofollow">Xtpacz</a>. Powered by <a rel="nofollow" target="_blank" href="https://hexo.io">Hexo</a>. Theme <a target="_blank" href="https://github.com/lotabout/very-simple">very-simple</a>.</div></div></div></footer><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.css"><script src="//cdn.bootcss.com/jquery/2.0.3/jquery.min.js"></script><script src="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.pack.js"></script><script>$(document).ready(function() {
    $(".fancybox").fancybox();
});
</script></body></html>